{"mappings":"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","sources":["<anon>","src/scripts/formula.js","src/scripts/horizontalLoop.js"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire60dc\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"k7Fc5\", function(module, exports) {\n\n$parcel$export(module.exports, \"initSciencePage\", () => $ea646a5b18efb62a$export$a71079573851442d);\n$parcel$export(module.exports, \"cleanupSciencePage\", () => $ea646a5b18efb62a$export$ed43c5b1eb9a3fd6);\n\nvar $2bvox = parcelRequire(\"2bvox\");\n\nvar $hR2D0 = parcelRequire(\"hR2D0\");\n\nvar $gkx87 = parcelRequire(\"gkx87\");\n\nvar $64aKy = parcelRequire(\"64aKy\");\n(0, $2bvox.gsap).registerPlugin((0, $hR2D0.ScrollTrigger), (0, $gkx87.SplitText));\nlet $ea646a5b18efb62a$var$_vennSVG = null;\nlet $ea646a5b18efb62a$var$_vennTL = null;\nlet $ea646a5b18efb62a$var$_vennClonedVideo = null;\nlet $ea646a5b18efb62a$var$_vennCanvas = null;\nlet $ea646a5b18efb62a$var$_vennCanvasRAF = null;\nfunction $ea646a5b18efb62a$export$a71079573851442d() {\n    try {\n        $ea646a5b18efb62a$var$createVennCircles();\n    } catch (e) {\n        console.error('Failed to init venn circles:', e);\n    }\n    // Initialize project tickers on the science page using the same behavior\n    // as the homepage. Targets use the same class `.home-project-scroll-txt-shell`.\n    try {\n        const scienceTickerCleanups = [];\n        document.querySelectorAll('.home-project-scroll-txt-shell, .science-scroll-txt-shell').forEach((shell, index)=>{\n            // Try common selectors first (homepage naming and the science page naming)\n            let txts = shell.querySelectorAll('.home-project-txt, .science-project-txt, [data-ticker-item]');\n            // Fallback: if no explicit items found, use direct children that look like ticker items\n            if (!txts || txts.length === 0) {\n                const children = Array.from(shell.children || []);\n                // Filter out elements that are clearly not visual/text items (e.g., script, svg, empty)\n                const candidates = children.filter((el)=>{\n                    try {\n                        const tag = (el.tagName || '').toLowerCase();\n                        if (tag === 'script' || tag === 'svg' || tag === 'canvas') return false;\n                        const txt = (el.textContent || '').trim();\n                        return txt.length > 0 || el.querySelector && el.querySelector('img,svg');\n                    } catch (e) {\n                        return false;\n                    }\n                });\n                if (candidates.length) txts = candidates;\n            }\n            if (!txts || txts.length === 0) {\n                // No ticker items found — log for debugging and skip\n                try {\n                    console.debug('[formula] no ticker items found in shell:', shell);\n                } catch (e) {}\n                return;\n            }\n            const initialDirection = index % 2 === 0 ? 1 : -1;\n            const cleanup = $ea646a5b18efb62a$var$introTicker(txts, shell, initialDirection);\n            if (typeof cleanup === 'function') scienceTickerCleanups.push(cleanup);\n        });\n        // expose cleanup so cleanupSciencePage can remove effects when navigating away\n        window._scienceTickerCleanup = ()=>{\n            try {\n                scienceTickerCleanups.forEach((fn)=>{\n                    try {\n                        fn();\n                    } catch (e) {}\n                });\n            } catch (e) {}\n        };\n    } catch (e) {}\n}\nwindow.initPageTransitions = function() {\n// Your page-specific GSAP intro animation here\n};\nfunction $ea646a5b18efb62a$export$ed43c5b1eb9a3fd6() {\n    // Remove SVG and kill timeline/scrolltrigger\n    try {\n        if ($ea646a5b18efb62a$var$_vennTL) {\n            try {\n                $ea646a5b18efb62a$var$_vennTL.scrollTrigger && $ea646a5b18efb62a$var$_vennTL.scrollTrigger.kill();\n            } catch (e) {}\n            try {\n                $ea646a5b18efb62a$var$_vennTL.kill();\n            } catch (e) {}\n            $ea646a5b18efb62a$var$_vennTL = null;\n        }\n        if ($ea646a5b18efb62a$var$_vennSVG && $ea646a5b18efb62a$var$_vennSVG.parentNode) {\n            $ea646a5b18efb62a$var$_vennSVG.parentNode.removeChild($ea646a5b18efb62a$var$_vennSVG);\n            $ea646a5b18efb62a$var$_vennSVG = null;\n        }\n        if ($ea646a5b18efb62a$var$_vennClonedVideo && $ea646a5b18efb62a$var$_vennClonedVideo.parentNode) {\n            try {\n                $ea646a5b18efb62a$var$_vennClonedVideo.parentNode.removeChild($ea646a5b18efb62a$var$_vennClonedVideo);\n            } catch (e) {}\n            $ea646a5b18efb62a$var$_vennClonedVideo = null;\n        }\n        if ($ea646a5b18efb62a$var$_vennCanvas) {\n            try {\n                cancelAnimationFrame($ea646a5b18efb62a$var$_vennCanvasRAF);\n            } catch (e) {}\n            try {\n                $ea646a5b18efb62a$var$_vennCanvas.parentNode && $ea646a5b18efb62a$var$_vennCanvas.parentNode.removeChild($ea646a5b18efb62a$var$_vennCanvas);\n            } catch (e) {}\n            $ea646a5b18efb62a$var$_vennCanvas = null;\n            $ea646a5b18efb62a$var$_vennCanvasRAF = null;\n        }\n    } catch (e) {\n        console.warn('cleanupSciencePage failed', e);\n    }\n    // Cleanup any project tickers initialized for the science page\n    try {\n        if (typeof window._scienceTickerCleanup === 'function') {\n            try {\n                window._scienceTickerCleanup();\n            } catch (e) {}\n            window._scienceTickerCleanup = null;\n        }\n    } catch (e) {}\n}\n// Ticker function copied/adapted from home.js so science page tickers behave the same\nfunction $ea646a5b18efb62a$var$introTicker(txtNodes, shell, initialDirection = 1) {\n    const baseSpeed = 1.2;\n    const maxSpeed = 8;\n    const velocityMult = 0.005;\n    const heroLoop = (0, $64aKy.default)(txtNodes, {\n        repeat: -1,\n        speed: baseSpeed,\n        reversed: initialDirection < 0\n    });\n    const absBaseSpeed = Math.abs(baseSpeed);\n    heroLoop.timeScale(absBaseSpeed);\n    let scrollTimeout;\n    let currentDirection = initialDirection;\n    const pauseLoop = ()=>{\n        (0, $2bvox.gsap).killTweensOf(heroLoop);\n        heroLoop.pause();\n    };\n    const resumeLoop = ()=>{\n        heroLoop.resume();\n        heroLoop.timeScale(absBaseSpeed);\n    };\n    const st = (0, $hR2D0.ScrollTrigger).create({\n        trigger: shell,\n        start: \"top+=20% bottom\",\n        end: \"bottom-=20% top\",\n        onUpdate: ({ isActive: isActive, getVelocity: getVelocity })=>{\n            if (!isActive) {\n                pauseLoop();\n                return;\n            }\n            (0, $2bvox.gsap).killTweensOf(heroLoop);\n            const scrollVelocity = getVelocity();\n            if (Math.abs(scrollVelocity) > 0.5) {\n                const scrollDirection = Math.sign(scrollVelocity);\n                const effectiveDirection = initialDirection < 0 ? -scrollDirection : scrollDirection;\n                currentDirection = effectiveDirection;\n                const boostAmount = Math.min(Math.abs(scrollVelocity * velocityMult), maxSpeed);\n                const effectiveSpeed = absBaseSpeed + Math.abs(effectiveDirection) * boostAmount;\n                heroLoop.timeScale(effectiveSpeed * Math.sign(effectiveDirection));\n            }\n            clearTimeout(scrollTimeout);\n            scrollTimeout = setTimeout(()=>{\n                (0, $2bvox.gsap).to(heroLoop, {\n                    timeScale: absBaseSpeed * Math.sign(currentDirection),\n                    duration: 0.5,\n                    ease: \"power1.out\",\n                    overwrite: true\n                });\n            }, 150);\n        },\n        onLeave: pauseLoop,\n        onEnter: resumeLoop,\n        onLeaveBack: pauseLoop,\n        onEnterBack: resumeLoop\n    });\n    return ()=>{\n        clearTimeout(scrollTimeout);\n        try {\n            st && st.kill && st.kill();\n        } catch (e) {}\n        (0, $2bvox.gsap).killTweensOf(heroLoop);\n        try {\n            heroLoop.kill && heroLoop.kill();\n        } catch (e) {}\n    };\n}\nfunction $ea646a5b18efb62a$var$createVennCircles() {\n    const shell = document.querySelector('.venn-shell');\n    if (!shell) {\n        console.warn(\".venn-shell not found \\u2014 skipping venn init\");\n        return;\n    }\n    // Get shell bounds to size SVG\n    const bounds = shell.getBoundingClientRect();\n    const width = Math.max(300, Math.round(bounds.width));\n    const height = Math.max(200, Math.round(bounds.height));\n    // Create SVG overlay positioned absolutely inside the shell\n    const svgNS = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(svgNS, 'svg');\n    svg.setAttribute('width', '100%');\n    svg.setAttribute('height', '100%');\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    svg.style.position = 'absolute';\n    svg.style.left = '0';\n    svg.style.top = '0';\n    // ensure svg overlays above any canvas/video we insert\n    svg.style.zIndex = '2';\n    svg.style.pointerEvents = 'none';\n    svg.style.overflow = 'visible';\n    // Two circles: left and right\n    const left = document.createElementNS(svgNS, 'circle');\n    const right = document.createElementNS(svgNS, 'circle');\n    // Starting positions (percent-based inside viewBox) - push them further to the edges\n    const cxLeft = Math.round(width * 0.12);\n    const cxRight = Math.round(width * 0.88);\n    const cy = Math.round(height * 0.5);\n    // Compute base and target radius (make circles 15% smaller than base)\n    const baseR = Math.round(Math.min(width, height) * 0.38);\n    const targetR = Math.round(baseR * 0.85);\n    // Initial radius (debug = set to target so circles are visible immediately)\n    left.setAttribute('cx', cxLeft);\n    left.setAttribute('cy', cy);\n    left.setAttribute('r', targetR);\n    // pick colors based on shell/background luminance so debug visuals are visible\n    const bgColor = window.getComputedStyle(shell).backgroundColor || window.getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';\n    const pickColors = (bg)=>{\n        // parse `rgb(a)?(...)`\n        try {\n            const nums = bg.replace(/[^0-9.,]/g, '').split(',').map((n)=>parseFloat(n));\n            const r = nums[0] || 255, g = nums[1] || 255, b = nums[2] || 255;\n            // relative luminance approximation\n            const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;\n            const darkBg = lum < 0.5;\n            // Use white outlines and a dotted stroke for both light and dark backgrounds.\n            // Small dots are achieved with a short dash length and spacing, plus round line caps.\n            if (darkBg) return {\n                fill: 'rgba(255,255,255,0.06)',\n                stroke: '#ffffff',\n                lensFill: 'rgba(255,255,255,0.08)',\n                strokeDash: '1 7',\n                strokeW: 2\n            };\n            return {\n                fill: 'rgba(0,100,255,0.12)',\n                stroke: '#ffffff',\n                lensFill: 'rgba(255,0,0,0.12)',\n                strokeDash: '1 7',\n                strokeW: 2\n            };\n        } catch (e) {\n            return {\n                fill: 'rgba(0,100,255,0.12)',\n                stroke: '#0366d6',\n                lensFill: 'rgba(255,0,0,0.12)',\n                strokeDash: '6 6',\n                strokeW: 2\n            };\n        }\n    };\n    const colors = pickColors(bgColor);\n    // Do not fill the circles so they don't block the video — keep stroke for visual guide\n    left.setAttribute('fill', 'none');\n    left.setAttribute('stroke', colors.stroke);\n    left.setAttribute('stroke-dasharray', colors.strokeDash);\n    left.setAttribute('stroke-width', colors.strokeW);\n    // round caps make short dash lengths look like dots\n    left.setAttribute('stroke-linecap', 'round');\n    // make the outline 50% opaque\n    left.setAttribute('stroke-opacity', '0.8');\n    right.setAttribute('cx', cxRight);\n    right.setAttribute('cy', cy);\n    right.setAttribute('r', targetR);\n    right.setAttribute('fill', 'none');\n    right.setAttribute('stroke', colors.stroke);\n    right.setAttribute('stroke-dasharray', colors.strokeDash);\n    right.setAttribute('stroke-width', colors.strokeW);\n    // round caps make short dash lengths look like dots\n    right.setAttribute('stroke-linecap', 'round');\n    // make the outline 50% opaque\n    right.setAttribute('stroke-opacity', '0.8');\n    svg.appendChild(left);\n    svg.appendChild(right);\n    // Create defs & clipPath for the lens intersection and a path to hold it\n    const defs = document.createElementNS(svgNS, 'defs');\n    const clipPath = document.createElementNS(svgNS, 'clipPath');\n    clipPath.setAttribute('id', 'venn-clip');\n    clipPath.setAttribute('clipPathUnits', 'userSpaceOnUse');\n    const lensPath = document.createElementNS(svgNS, 'path');\n    lensPath.setAttribute('d', '');\n    // visible for debug; set to '#000' or 'none' for production\n    lensPath.setAttribute('fill', colors.lensFill || 'rgba(255,0,0,0.12)');\n    clipPath.appendChild(lensPath);\n    defs.appendChild(clipPath);\n    // Also create an SVG mask as a fallback — masks sometimes render where clipPath does not\n    const maskEl = document.createElementNS(svgNS, 'mask');\n    maskEl.setAttribute('id', 'venn-mask');\n    maskEl.setAttribute('maskUnits', 'userSpaceOnUse');\n    // a black rect background (masked-out area)\n    const maskBg = document.createElementNS(svgNS, 'rect');\n    maskBg.setAttribute('x', '0');\n    maskBg.setAttribute('y', '0');\n    maskBg.setAttribute('width', String(width));\n    maskBg.setAttribute('height', String(height));\n    maskBg.setAttribute('fill', '#000');\n    const maskPath = document.createElementNS(svgNS, 'path');\n    maskPath.setAttribute('d', '');\n    // white path shows through the mask\n    maskPath.setAttribute('fill', '#fff');\n    maskEl.appendChild(maskBg);\n    maskEl.appendChild(maskPath);\n    defs.appendChild(maskEl);\n    svg.appendChild(defs);\n    // Ensure the shell is positioned so the absolute SVG overlays correctly\n    const prevPosition = window.getComputedStyle(shell).position;\n    if (prevPosition === 'static' || !prevPosition) try {\n        shell.style.position = 'relative';\n    } catch (e) {}\n    // Append svg to shell\n    shell.appendChild(svg);\n    $ea646a5b18efb62a$var$_vennSVG = svg;\n    // Locate user-provided label shells (prefer existing DOM nodes created in Webflow)\n    let leftLabel = null;\n    let rightLabel = null;\n    try {\n        leftLabel = shell.querySelector('.venn-txt-shell-left');\n        rightLabel = shell.querySelector('.venn-txt-shell-right');\n        [\n            leftLabel,\n            rightLabel\n        ].forEach((el)=>{\n            if (!el) return;\n            try {\n                // ensure centering transform so (left,top) map the element's center to the coord\n                el.style.position = el.style.position || 'absolute';\n                el.style.transform = el.style.transform || 'translate(-50%,-50%)';\n                el.style.pointerEvents = 'none';\n                el.style.zIndex = el.style.zIndex || '3';\n            } catch (e) {}\n        });\n    } catch (e) {}\n    // Clone a page video into the shell (if present) to ensure we can apply clip/mask\n    try {\n        const pageVideo = document.querySelector('video');\n        if (pageVideo && !pageVideo.closest('.venn-shell')) {\n            const clone = pageVideo.cloneNode(true);\n            // Ensure autoplay will be permitted (muted) and attributes are explicit\n            try {\n                clone.muted = true;\n            } catch (e) {}\n            try {\n                clone.setAttribute('muted', '');\n            } catch (e) {}\n            try {\n                clone.autoplay = true;\n            } catch (e) {}\n            try {\n                clone.setAttribute('autoplay', '');\n            } catch (e) {}\n            try {\n                clone.loop = true;\n            } catch (e) {}\n            try {\n                clone.setAttribute('loop', '');\n            } catch (e) {}\n            try {\n                clone.playsInline = true;\n            } catch (e) {}\n            try {\n                clone.setAttribute('playsinline', '');\n            } catch (e) {}\n            try {\n                clone.setAttribute('preload', 'auto');\n            } catch (e) {}\n            clone.style.position = 'absolute';\n            clone.style.left = '0';\n            clone.style.top = '0';\n            clone.style.width = '100%';\n            clone.style.height = '100%';\n            clone.style.objectFit = 'cover';\n            clone.style.zIndex = '1';\n            clone.style.pointerEvents = 'none';\n            clone.style.opacity = '1';\n            try {\n                shell.insertBefore(clone, svg);\n            } catch (e) {\n                shell.appendChild(clone);\n            }\n            // Try to start playback; some browsers require play() call even if autoplay attribute present\n            try {\n                const p = clone.play();\n                if (p && p.catch) p.catch(()=>{});\n            } catch (e) {}\n            $ea646a5b18efb62a$var$_vennClonedVideo = clone;\n            // Try to start the original page video as well (may be the source)\n            try {\n                const p = pageVideo.play();\n                if (p && p.catch) p.catch(()=>{\n                    // try muting and playing again\n                    try {\n                        pageVideo.muted = true;\n                        pageVideo.setAttribute('muted', '');\n                    } catch (e) {}\n                    try {\n                        pageVideo.play().catch(()=>{});\n                    } catch (e) {}\n                });\n            } catch (e) {}\n            // ensure the clone plays\n            try {\n                const p2 = clone.play();\n                if (p2 && p2.catch) p2.catch(()=>{});\n            } catch (e) {}\n            // if autoplay is blocked, resume on first user interaction\n            const ensurePlay = (v)=>{\n                try {\n                    v.play().catch(()=>{});\n                } catch (e) {}\n            };\n            const resumeOnGesture = ()=>{\n                try {\n                    ensurePlay(pageVideo);\n                    ensurePlay(clone);\n                } catch (e) {}\n            };\n            document.addEventListener('click', resumeOnGesture, {\n                once: true\n            });\n        }\n    } catch (e) {}\n    // Canvas fallback: draw frames from an existing video (inside shell) into a canvas\n    try {\n        const pageVid = shell.querySelector('video');\n        if (pageVid) {\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            canvas.style.position = 'absolute';\n            canvas.style.left = '0';\n            canvas.style.top = '0';\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.zIndex = '1';\n            canvas.style.pointerEvents = 'none';\n            try {\n                shell.insertBefore(canvas, svg);\n            } catch (e) {\n                shell.appendChild(canvas);\n            }\n            $ea646a5b18efb62a$var$_vennCanvas = canvas;\n            const ctx = canvas.getContext('2d');\n            // Ensure the shell video is playing; try to play and fallback to muting if blocked\n            try {\n                const playPromise = pageVid.play();\n                if (playPromise && playPromise.catch) playPromise.catch(()=>{\n                    try {\n                        pageVid.muted = true;\n                        pageVid.setAttribute('muted', '');\n                    } catch (e) {}\n                    try {\n                        pageVid.play().catch(()=>{});\n                    } catch (e) {}\n                });\n            } catch (e) {}\n            document.addEventListener('click', ()=>{\n                try {\n                    pageVid.play().catch(()=>{});\n                } catch (e) {}\n            }, {\n                once: true\n            });\n            // draw loop: compute a minimal scale so the drawn video fully covers the lens\n            const draw = ()=>{\n                try {\n                    if (pageVid && pageVid.readyState >= 2) {\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        const vw = pageVid.videoWidth || pageVid.clientWidth || canvas.width;\n                        const vh = pageVid.videoHeight || pageVid.clientHeight || canvas.height;\n                        // compute minimal scale from lens polygon bbox so we don't reveal edges\n                        let autoScale = 0.75; // fallback default\n                        try {\n                            const poly = $ea646a5b18efb62a$var$lensPolygonPoints(params.lx, params.cy, params.lr, params.rx, params.cy, params.rr, 28);\n                            if (poly && poly.length) {\n                                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n                                for (let p of poly){\n                                    if (p.x < minX) minX = p.x;\n                                    if (p.y < minY) minY = p.y;\n                                    if (p.x > maxX) maxX = p.x;\n                                    if (p.y > maxY) maxY = p.y;\n                                }\n                                const bboxW = Math.max(1, maxX - minX);\n                                const bboxH = Math.max(1, maxY - minY);\n                                const minScaleW = bboxW / canvas.width;\n                                const minScaleH = bboxH / canvas.height;\n                                const minScale = Math.max(minScaleW, minScaleH);\n                                // add a small safety margin to avoid crisp-edge reveals\n                                autoScale = Math.min(1, minScale * 1.03);\n                                // ensure not tiny\n                                autoScale = Math.max(autoScale, 0.2);\n                            }\n                        } catch (e) {\n                            autoScale = 0.75;\n                        }\n                        const destW = Math.round(canvas.width * autoScale);\n                        const destH = Math.round(canvas.height * autoScale);\n                        const dx = Math.round((canvas.width - destW) / 2);\n                        const dy = Math.round((canvas.height - destH) / 2);\n                        try {\n                            ctx.drawImage(pageVid, 0, 0, vw, vh, dx, dy, destW, destH);\n                        } catch (e) {\n                            // fallback to simple draw if dimension mapping fails\n                            try {\n                                ctx.drawImage(pageVid, dx, dy, destW, destH);\n                            } catch (e) {}\n                        }\n                    }\n                } catch (e) {}\n                $ea646a5b18efb62a$var$_vennCanvasRAF = requestAnimationFrame(draw);\n            };\n            $ea646a5b18efb62a$var$_vennCanvasRAF = requestAnimationFrame(draw);\n        }\n    } catch (e) {}\n    // Visible debug overlay (helps when console is muted globally)\n    const DEBUG_OVLY = false; // set true to enable\n    let debugEl = null;\n    if (DEBUG_OVLY) {\n        debugEl = document.createElement('div');\n        debugEl.style.position = 'absolute';\n        debugEl.style.right = '12px';\n        // move below the site's nav/header so text isn't obscured\n        debugEl.style.top = '80px';\n        debugEl.style.padding = '6px 8px';\n        debugEl.style.background = 'rgba(0,0,0,0.65)';\n        debugEl.style.color = '#fff';\n        debugEl.style.fontFamily = 'monospace';\n        debugEl.style.fontSize = '11px';\n        debugEl.style.zIndex = 9999;\n        debugEl.style.pointerEvents = 'none';\n        debugEl.style.whiteSpace = 'pre-wrap';\n        debugEl.style.maxWidth = 'calc(100% - 160px)';\n        debugEl.style.overflow = 'hidden';\n        debugEl.textContent = 'venn: initializing...';\n        // append to shell (not svg) so HTML can render\n        try {\n            shell.appendChild(debugEl);\n        } catch (e) {}\n    }\n    // Target radius is computed above (baseR/targetR) and used for params\n    // Build a timeline controlled by scroll\n    // Since the shell is full-viewport (100vh), when its top reaches the top of the\n    // viewport it is fully visible. Pin it there and run the animation while pinned.\n    const tl = (0, $2bvox.gsap).timeline({\n        scrollTrigger: {\n            trigger: shell,\n            start: 'top top',\n            end: '+=100%',\n            pin: true,\n            // Scrub the timeline so the animation progress follows the user's scroll\n            scrub: 0.6,\n            markers: false\n        }\n    });\n    // Param object we will animate (and use to update circles + lens)\n    // We'll keep radii constant and animate only horizontal positions so circles slide toward each other\n    const params = {\n        lx: cxLeft,\n        rx: cxRight,\n        cy: cy,\n        lr: targetR,\n        rr: targetR\n    };\n    // distance in pixels between the visible stroke and the video mask\n    const maskCushion = 2;\n    const updateShapes = ()=>{\n        try {\n            left.setAttribute('cx', Math.round(params.lx));\n            left.setAttribute('cy', Math.round(params.cy));\n            left.setAttribute('r', Math.round(params.lr));\n            right.setAttribute('cx', Math.round(params.rx));\n            right.setAttribute('cy', Math.round(params.cy));\n            right.setAttribute('r', Math.round(params.rr));\n            // Position HTML labels (if present) to the circle centers. We map viewBox\n            // coordinates -> percent so absolutely-positioned divs inside `shell` align.\n            try {\n                if (leftLabel) {\n                    leftLabel.style.left = `${(params.lx / width * 100).toFixed(4)}%`;\n                    leftLabel.style.top = `${(params.cy / height * 100).toFixed(4)}%`;\n                }\n                if (rightLabel) {\n                    rightLabel.style.left = `${(params.rx / width * 100).toFixed(4)}%`;\n                    rightLabel.style.top = `${(params.cy / height * 100).toFixed(4)}%`;\n                }\n            } catch (e) {}\n            // compute lens path and set it on lensPath\n            // shrink the radii by half the stroke width plus a small cushion so the dotted\n            // stroke does not overlap the revealed video area.\n            const insetLr = Math.max(0, params.lr - (colors && colors.strokeW ? colors.strokeW : 2) / 2 - maskCushion);\n            const insetRr = Math.max(0, params.rr - (colors && colors.strokeW ? colors.strokeW : 2) / 2 - maskCushion);\n            const d = $ea646a5b18efb62a$var$lensPathForCircles(params.lx, params.cy, insetLr, params.rx, params.cy, insetRr);\n            lensPath.setAttribute('d', d || '');\n            // apply clipPath to the .venn-video-shell parent (more robust with background-cover videos)\n            const videoShellEl = document.querySelector('.venn-video-shell');\n            const videoEl = videoShellEl ? videoShellEl.querySelector('video') : null;\n            // find the deepest visible element that likely contains the visual (video or background-image)\n            const findVisualTarget = (root)=>{\n                if (!root) return null;\n                // prefer an actual video element\n                const vid = root.querySelector('video');\n                if (vid) return vid;\n                // if the root itself has a background image, use it\n                try {\n                    const csRoot = getComputedStyle(root);\n                    if (csRoot && csRoot.backgroundImage && csRoot.backgroundImage !== 'none') return root;\n                } catch (e) {}\n                // otherwise search children for a background image\n                const walker = root.querySelectorAll('*');\n                for(let i = 0; i < walker.length; i++)try {\n                    const el = walker[i];\n                    const cs = getComputedStyle(el);\n                    if (cs && cs.backgroundImage && cs.backgroundImage !== 'none') return el;\n                } catch (e) {}\n                return root;\n            };\n            // Prefer the canvas as the visual target if it exists (we draw frames there)\n            const visualTarget = $ea646a5b18efb62a$var$_vennCanvas || findVisualTarget(videoShellEl) || videoShellEl;\n            // prefer a full-URL reference which is more reliable across browsers\n            const frag = '#venn-clip';\n            const localRef = `url(${frag})`;\n            const fullRef = (()=>{\n                try {\n                    return `url(${location.href.replace(/#.*$/, '')}${frag})`;\n                } catch (e) {\n                    return localRef;\n                }\n            })();\n            const applyRef = (el)=>{\n                try {\n                    el.style.clipPath = fullRef;\n                    el.style.webkitClipPath = fullRef;\n                    // also try the local ref as a fallback\n                    // some browsers accept one or the other\n                    // (setting both is fine)\n                    el.style.clipPath = el.style.clipPath || localRef;\n                    el.style.webkitClipPath = el.style.webkitClipPath || localRef;\n                    el.style.overflow = 'hidden';\n                } catch (e) {}\n            };\n            // Apply clip/mask to the visual target (video element or background element)\n            if (visualTarget) applyRef(visualTarget);\n            // Update the mask path so we can apply an SVG mask as a fallback\n            try {\n                const dStr = lensPath.getAttribute('d') || '';\n                // set mask path\n                try {\n                    maskPath.setAttribute('d', dStr || '');\n                } catch (e) {}\n                if (dStr) {\n                    // also try CSS path() fallback for clipPath\n                    const cssPath = `path('${dStr.replace(/'/g, \"\\\\'\")}')`;\n                    if (videoShellEl) try {\n                        videoShellEl.style.clipPath = cssPath;\n                        videoShellEl.style.webkitClipPath = cssPath;\n                    } catch (e) {}\n                    if (videoEl) try {\n                        videoEl.style.clipPath = cssPath;\n                        videoEl.style.webkitClipPath = cssPath;\n                    } catch (e) {}\n                }\n            } catch (e) {}\n            // As an additional, highly-compatible fallback: approximate the lens with a polygon\n            // and apply via CSS `clip-path: polygon(...)` which you noted worked from Webflow.\n            try {\n                // use the inset radii so the polygon mask sits inside the stroke by maskCushion\n                const polyLr = Math.max(0, params.lr - (colors && colors.strokeW ? colors.strokeW : 2) / 2 - maskCushion);\n                const polyRr = Math.max(0, params.rr - (colors && colors.strokeW ? colors.strokeW : 2) / 2 - maskCushion);\n                const polygonPoints = $ea646a5b18efb62a$var$lensPolygonPoints(params.lx, params.cy, polyLr, params.rx, params.cy, polyRr, 24);\n                if (polygonPoints && polygonPoints.length) {\n                    // convert to percent coordinates relative to the svg/viewBox width/height\n                    const polyStr = polygonPoints.map((p)=>`${(p.x / width * 100).toFixed(3)}% ${(p.y / height * 100).toFixed(3)}%`).join(', ');\n                    try {\n                        visualTarget.style.clipPath = `polygon(${polyStr})`;\n                        visualTarget.style.webkitClipPath = `polygon(${polyStr})`;\n                    } catch (e) {}\n                }\n            } catch (e) {}\n            // Apply the SVG mask (url) as a final fallback — some browsers support masks better\n            try {\n                const maskFrag = '#venn-mask';\n                const fullMaskRef = `url(${location.href.replace(/#.*$/, '')}${maskFrag})`;\n                if (videoShellEl) try {\n                    videoShellEl.style.mask = fullMaskRef;\n                    videoShellEl.style.webkitMask = fullMaskRef;\n                } catch (e) {}\n                if (videoEl) try {\n                    videoEl.style.mask = fullMaskRef;\n                    videoEl.style.webkitMask = fullMaskRef;\n                } catch (e) {}\n            } catch (e) {}\n            // Update visible debug overlay (useful if console logs are muted)\n            try {\n                if (debugEl) {\n                    const dStr = lensPath.getAttribute('d') || '';\n                    const shellClip = videoShellEl ? getComputedStyle(videoShellEl).clipPath || getComputedStyle(videoShellEl).webkitClipPath || 'none' : 'n/a';\n                    const vidClip = videoEl ? getComputedStyle(videoEl).clipPath || getComputedStyle(videoEl).webkitClipPath || 'none' : 'n/a';\n                    const newText = `lens:${dStr ? 'yes' : 'no'} len:${dStr.length}\\nclipShell:${shellClip}\\nclipVideo:${vidClip}\\nfullRef:${fullRef}\\nvideoEl:${!!videoEl}\\nclone:${!!$ea646a5b18efb62a$var$_vennClonedVideo}`;\n                    if (newText !== lastDebugText) {\n                        debugEl.textContent = newText;\n                        lastDebugText = newText;\n                    }\n                }\n            } catch (e) {}\n        } catch (e) {}\n    };\n    // Animate params so circles slide horizontally toward each other while the\n    // container is pinned. We want a 22% overlap of the circles' diameter.\n    // For equal radii r, overlap_distance = 0.22 * (2r) = 0.44r\n    // center_distance = 2r - overlap_distance = 1.56r\n    const finalCenterDistance = 1.56 * targetR;\n    const centerX = width / 2;\n    const finalLx = Math.round(centerX - finalCenterDistance / 2);\n    const finalRx = Math.round(centerX + finalCenterDistance / 2);\n    tl.to(params, {\n        lx: finalLx,\n        duration: 1.2,\n        ease: 'power2.out',\n        onUpdate: updateShapes\n    }, 0);\n    tl.to(params, {\n        rx: finalRx,\n        duration: 1.2,\n        ease: 'power2.out',\n        onUpdate: updateShapes\n    }, 0);\n    // If the page includes an element that should appear on top of the video\n    // inside the lens (class `.venn-vid-txt`), animate its blur from 20px -> 0\n    // starting when the circles first begin to overlap. We compute the relative\n    // fraction of the params animation where overlap starts and insert a scrubbed\n    // tween into the same timeline so it follows the scroll scrub.\n    try {\n        const vidTxt = shell.querySelector('.venn-vid-txt');\n        if (vidTxt) {\n            // use GSAP to set initial state (clean and performant)\n            try {\n                (0, $2bvox.gsap).set(vidTxt, {\n                    filter: 'blur(20px)',\n                    opacity: 0,\n                    willChange: 'filter,opacity'\n                });\n            } catch (e) {}\n            // compute fraction where the circles begin to overlap (center distance < sum of radii)\n            const initialDist = cxRight - cxLeft;\n            const finalDist = finalRx - finalLx;\n            const rSum = params.lr + params.rr;\n            if (Math.abs(finalDist - initialDist) > 0.0001) {\n                let frac = (rSum - initialDist) / (finalDist - initialDist);\n                frac = Math.max(0, Math.min(1, frac));\n                const tlDur = tl.duration() || 1.2;\n                // start slightly earlier so the reveal begins before overlap; tweakable\n                const earlyFraction = 0.45; // start 70% of timeline earlier\n                let startTime = frac * tlDur - earlyFraction * tlDur;\n                startTime = Math.max(0, startTime);\n                const remaining = Math.max(0.001, tlDur - startTime);\n                try {\n                    // use fromTo so both filter and opacity are driven together and rendered by GSAP\n                    tl.fromTo(vidTxt, {\n                        filter: 'blur(20px)',\n                        opacity: 0\n                    }, {\n                        filter: 'blur(0px)',\n                        opacity: 1,\n                        duration: remaining,\n                        ease: 'none'\n                    }, startTime);\n                } catch (e) {}\n            }\n        }\n    } catch (e) {}\n    // Animate the venn-sub-txt elements (left and right side text)\n    // using SplitText to fade/blur in from bottom after circles finish joining\n    try {\n        const subTextElements = shell.querySelectorAll('.venn-sub-txt');\n        if (subTextElements.length > 0) {\n            const tlDur = tl.duration() || 1.2;\n            // Start the text animation after circles are fully overlapped (100% through)\n            const textStartTime = tlDur * 1.0; // Start at 100% through the animation\n            const textDuration = tlDur * 0.4; // Use 40% of timeline for text animation\n            subTextElements.forEach((textEl)=>{\n                // Split the text into words\n                const split = new (0, $gkx87.SplitText)(textEl, {\n                    type: 'words'\n                });\n                // Set initial state: invisible, blurred, and shifted down\n                (0, $2bvox.gsap).set(split.words, {\n                    opacity: 0,\n                    filter: 'blur(10px)',\n                    y: 15\n                });\n                // Animate words in from bottom with blur fade\n                tl.to(split.words, {\n                    opacity: 1,\n                    filter: 'blur(0px)',\n                    y: 0,\n                    duration: textDuration,\n                    stagger: 0.09,\n                    ease: 'power2.out'\n                }, textStartTime);\n            });\n            // Extend the pin duration to give users time to read\n            if (tl.scrollTrigger) {\n                tl.scrollTrigger.vars.end = '+=200%'; // Increased from 100% to 200%\n                tl.scrollTrigger.refresh();\n            }\n        }\n    } catch (e) {\n        console.error('Error setting up venn-sub-txt animation:', e);\n    }\n    // initialize\n    updateShapes();\n    $ea646a5b18efb62a$var$_vennTL = tl;\n}\n// Compute SVG path string for the lens (intersection) of two circles\nfunction $ea646a5b18efb62a$var$lensPathForCircles(x1, y1, r1, x2, y2, r2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const d = Math.hypot(dx, dy);\n    if (d <= 0.0001) return '';\n    // no intersection\n    if (d >= r1 + r2) return '';\n    // one circle inside another -> return the smaller circle path\n    if (d <= Math.abs(r1 - r2)) {\n        const r = Math.min(r1, r2);\n        const cx = r1 < r2 ? x1 : x2;\n        const cy = r1 < r2 ? y1 : y2;\n        return $ea646a5b18efb62a$var$circlePath(cx, cy, r);\n    }\n    // intersection points\n    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n    const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));\n    const xm = x1 + a * dx / d;\n    const ym = y1 + a * dy / d;\n    const rx = -dy * (h / d);\n    const ry = dx * (h / d);\n    const xi1 = xm + rx;\n    const yi1 = ym + ry;\n    const xi2 = xm - rx;\n    const yi2 = ym - ry;\n    // Build path: arc on circle1 from P1 to P2, then arc on circle2 from P2 back to P1\n    const largeArc1 = 0;\n    const sweep1 = 1;\n    const largeArc2 = 0;\n    const sweep2 = 1;\n    // Use absolute coords\n    const path = `M ${xi1} ${yi1} ` + `A ${r1} ${r1} 0 ${largeArc1} ${sweep1} ${xi2} ${yi2} ` + `A ${r2} ${r2} 0 ${largeArc2} ${sweep2} ${xi1} ${yi1} Z`;\n    return path;\n}\nfunction $ea646a5b18efb62a$var$circlePath(cx, cy, r) {\n    // draw a full circle as path\n    return `M ${cx - r} ${cy} ` + `a ${r} ${r} 0 1 0 ${r * 2} 0 ` + `a ${r} ${r} 0 1 0 ${-r * 2} 0 Z`;\n}\n// Approximate the lens intersection area by sampling points along both arcs\nfunction $ea646a5b18efb62a$var$lensPolygonPoints(x1, y1, r1, x2, y2, r2, segments = 24) {\n    // if no intersection, return empty\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const d = Math.hypot(dx, dy);\n    if (d <= 0.0001) return [];\n    if (d >= r1 + r2) return [];\n    if (d <= Math.abs(r1 - r2)) {\n        // return circle approximated\n        const r = Math.min(r1, r2);\n        const cx = r1 < r2 ? x1 : x2;\n        const cy = r1 < r2 ? y1 : y2;\n        const pts = [];\n        for(let i = 0; i < segments; i++){\n            const a = i / segments * Math.PI * 2;\n            pts.push({\n                x: cx + Math.cos(a) * r,\n                y: cy + Math.sin(a) * r\n            });\n        }\n        return pts;\n    }\n    // compute intersection arc endpoints (reuse math from lensPathForCircles)\n    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n    const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));\n    const xm = x1 + a * dx / d;\n    const ym = y1 + a * dy / d;\n    const rx = -dy * (h / d);\n    const ry = dx * (h / d);\n    const xi1 = xm + rx;\n    const yi1 = ym + ry;\n    const xi2 = xm - rx;\n    const yi2 = ym - ry;\n    // angles for arcs\n    const ang1 = Math.atan2(yi1 - y1, xi1 - x1);\n    const ang2 = Math.atan2(yi2 - y1, xi2 - x1);\n    const ang3 = Math.atan2(yi2 - y2, xi2 - x2);\n    const ang4 = Math.atan2(yi1 - y2, xi1 - x2);\n    // normalize sweep from ang1 -> ang2 on circle1, and ang3 -> ang4 on circle2\n    const pts = [];\n    const segHalf = Math.ceil(segments / 2);\n    // circle1 arc from ang1 to ang2\n    for(let i = 0; i <= segHalf; i++){\n        const t = i / segHalf;\n        // interpolate angle on shorter arc\n        let a1 = ang1 + $ea646a5b18efb62a$var$shortestAngleDiff(ang1, ang2) * t;\n        pts.push({\n            x: x1 + Math.cos(a1) * r1,\n            y: y1 + Math.sin(a1) * r1\n        });\n    }\n    // circle2 arc from ang3 to ang4\n    for(let i = 0; i <= segHalf; i++){\n        const t = i / segHalf;\n        let a2 = ang3 + $ea646a5b18efb62a$var$shortestAngleDiff(ang3, ang4) * t;\n        pts.push({\n            x: x2 + Math.cos(a2) * r2,\n            y: y2 + Math.sin(a2) * r2\n        });\n    }\n    return pts;\n}\nfunction $ea646a5b18efb62a$var$shortestAngleDiff(a, b) {\n    let diff = b - a;\n    while(diff < -Math.PI)diff += Math.PI * 2;\n    while(diff > Math.PI)diff -= Math.PI * 2;\n    return diff;\n}\n\n});\nparcelRegister(\"64aKy\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $46ab747bac60427b$export$2e2bcd8739ae039);\n\nvar $2bvox = parcelRequire(\"2bvox\");\nfunction $46ab747bac60427b$export$2e2bcd8739ae039(items, config) {\n    items = (0, $2bvox.default).utils.toArray(items);\n    config = config || {};\n    let tl = (0, $2bvox.default).timeline({\n        repeat: config.repeat,\n        paused: config.paused,\n        defaults: {\n            ease: 'none'\n        },\n        onReverseComplete: ()=>tl.totalTime(tl.rawTime() + tl.duration() * 100)\n    }), length = items.length, startX = items[0].offsetLeft, times = [], widths = [], xPercents = [], curIndex = 0, pixelsPerSecond = (config.speed || 1) * 100, snap = config.snap === false ? (v)=>v : (0, $2bvox.default).utils.snap(config.snap || 1), totalWidth, curX, distanceToStart, distanceToLoop, item, i;\n    (0, $2bvox.default).set(items, {\n        // convert \"x\" to \"xPercent\" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.\n        xPercent: (i, el)=>{\n            let w = widths[i] = parseFloat((0, $2bvox.default).getProperty(el, 'width', 'px'));\n            xPercents[i] = snap(parseFloat((0, $2bvox.default).getProperty(el, 'x', 'px')) / w * 100 + (0, $2bvox.default).getProperty(el, 'xPercent'));\n            return xPercents[i];\n        }\n    });\n    (0, $2bvox.default).set(items, {\n        x: 0\n    });\n    totalWidth = items[length - 1].offsetLeft + xPercents[length - 1] / 100 * widths[length - 1] - startX + items[length - 1].offsetWidth * (0, $2bvox.default).getProperty(items[length - 1], 'scaleX') + (parseFloat(config.paddingRight) || 0);\n    for(i = 0; i < length; i++){\n        item = items[i];\n        curX = xPercents[i] / 100 * widths[i];\n        distanceToStart = item.offsetLeft + curX - startX;\n        distanceToLoop = distanceToStart + widths[i] * (0, $2bvox.default).getProperty(item, 'scaleX');\n        tl.to(item, {\n            xPercent: snap((curX - distanceToLoop) / widths[i] * 100),\n            duration: distanceToLoop / pixelsPerSecond\n        }, 0).fromTo(item, {\n            xPercent: snap((curX - distanceToLoop + totalWidth) / widths[i] * 100)\n        }, {\n            xPercent: xPercents[i],\n            duration: (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,\n            immediateRender: false\n        }, distanceToLoop / pixelsPerSecond).add('label' + i, distanceToStart / pixelsPerSecond);\n        times[i] = distanceToStart / pixelsPerSecond;\n    }\n    function toIndex(index, vars) {\n        vars = vars || {};\n        Math.abs(index - curIndex) > length / 2 && (index += index > curIndex ? -length : length); // always go in the shortest direction\n        let newIndex = (0, $2bvox.default).utils.wrap(0, length, index), time = times[newIndex];\n        if (time > tl.time() !== index > curIndex) {\n            // if we're wrapping the timeline's playhead, make the proper adjustments\n            vars.modifiers = {\n                time: (0, $2bvox.default).utils.wrap(0, tl.duration())\n            };\n            time += tl.duration() * (index > curIndex ? 1 : -1);\n        }\n        curIndex = newIndex;\n        vars.overwrite = true;\n        return tl.tweenTo(time, vars);\n    }\n    tl.next = (vars)=>toIndex(curIndex + 1, vars);\n    tl.previous = (vars)=>toIndex(curIndex - 1, vars);\n    tl.current = ()=>curIndex;\n    tl.toIndex = (index, vars)=>toIndex(index, vars);\n    tl.times = times;\n    tl.progress(1, true).progress(0, true); // pre-render for performance\n    if (config.reversed) {\n        tl.vars.onReverseComplete();\n        tl.reverse();\n    }\n    return tl;\n}\n\n});\n\n\n})();\n//# sourceMappingURL=formula.925b5d0f.js.map\n","import { gsap } from \"gsap\";\nimport { ScrollTrigger } from \"gsap/ScrollTrigger\";\nimport { SplitText } from \"gsap/SplitText\";\nimport horizontalLoop from \"./horizontalLoop\";\n\ngsap.registerPlugin(ScrollTrigger, SplitText);\n\nlet _vennSVG = null;\nlet _vennTL = null;\nlet _vennClonedVideo = null;\nlet _vennCanvas = null;\nlet _vennCanvasRAF = null;\n\nexport function initSciencePage() {\n  try {\n    createVennCircles();\n  } catch (e) {\n    console.error('Failed to init venn circles:', e);\n  }\n\n  // Initialize project tickers on the science page using the same behavior\n  // as the homepage. Targets use the same class `.home-project-scroll-txt-shell`.\n  try {\n    const scienceTickerCleanups = [];\n    document.querySelectorAll('.home-project-scroll-txt-shell, .science-scroll-txt-shell').forEach((shell, index) => {\n      // Try common selectors first (homepage naming and the science page naming)\n      let txts = shell.querySelectorAll('.home-project-txt, .science-project-txt, [data-ticker-item]');\n      // Fallback: if no explicit items found, use direct children that look like ticker items\n      if (!txts || txts.length === 0) {\n        const children = Array.from(shell.children || []);\n        // Filter out elements that are clearly not visual/text items (e.g., script, svg, empty)\n        const candidates = children.filter(el => {\n          try {\n            const tag = (el.tagName || '').toLowerCase();\n            if (tag === 'script' || tag === 'svg' || tag === 'canvas') return false;\n            const txt = (el.textContent || '').trim();\n            return txt.length > 0 || el.querySelector && el.querySelector('img,svg');\n          } catch (e) { return false; }\n        });\n        if (candidates.length) txts = candidates;\n      }\n\n      if (!txts || txts.length === 0) {\n        // No ticker items found — log for debugging and skip\n        try { console.debug('[formula] no ticker items found in shell:', shell); } catch (e) {}\n        return;\n      }\n\n      const initialDirection = index % 2 === 0 ? 1 : -1;\n      const cleanup = introTicker(txts, shell, initialDirection);\n      if (typeof cleanup === 'function') scienceTickerCleanups.push(cleanup);\n    });\n    // expose cleanup so cleanupSciencePage can remove effects when navigating away\n    window._scienceTickerCleanup = () => {\n      try {\n        scienceTickerCleanups.forEach(fn => { try { fn(); } catch (e) {} });\n      } catch (e) {}\n    };\n  } catch (e) { /* ignore */ }\n}\n\nwindow.initPageTransitions = function() {\n  // Your page-specific GSAP intro animation here\n};\n\nexport function cleanupSciencePage() {\n  // Remove SVG and kill timeline/scrolltrigger\n  try {\n    if (_vennTL) {\n      try { _vennTL.scrollTrigger && _vennTL.scrollTrigger.kill(); } catch (e) {}\n      try { _vennTL.kill(); } catch (e) {}\n      _vennTL = null;\n    }\n    if (_vennSVG && _vennSVG.parentNode) {\n      _vennSVG.parentNode.removeChild(_vennSVG);\n      _vennSVG = null;\n    }\n    if (_vennClonedVideo && _vennClonedVideo.parentNode) {\n      try { _vennClonedVideo.parentNode.removeChild(_vennClonedVideo); } catch (e) {}\n      _vennClonedVideo = null;\n    }\n    if (_vennCanvas) {\n      try { cancelAnimationFrame(_vennCanvasRAF); } catch (e) {}\n      try { _vennCanvas.parentNode && _vennCanvas.parentNode.removeChild(_vennCanvas); } catch (e) {}\n      _vennCanvas = null;\n      _vennCanvasRAF = null;\n    }\n  } catch (e) { console.warn('cleanupSciencePage failed', e); }\n\n  // Cleanup any project tickers initialized for the science page\n  try {\n    if (typeof window._scienceTickerCleanup === 'function') {\n      try { window._scienceTickerCleanup(); } catch (e) {}\n      window._scienceTickerCleanup = null;\n    }\n  } catch (e) {}\n}\n\n// Ticker function copied/adapted from home.js so science page tickers behave the same\nfunction introTicker(txtNodes, shell, initialDirection = 1) {\n  const baseSpeed = 1.2;\n  const maxSpeed = 8;\n  const velocityMult = 0.005;\n\n  const heroLoop = horizontalLoop(txtNodes, {\n    repeat: -1,\n    speed: baseSpeed,\n    reversed: initialDirection < 0\n  });\n\n  const absBaseSpeed = Math.abs(baseSpeed);\n  heroLoop.timeScale(absBaseSpeed);\n\n  let scrollTimeout;\n  let currentDirection = initialDirection;\n\n  const pauseLoop = () => {\n    gsap.killTweensOf(heroLoop);\n    heroLoop.pause();\n  };\n\n  const resumeLoop = () => {\n    heroLoop.resume();\n    heroLoop.timeScale(absBaseSpeed);\n  };\n\n  const st = ScrollTrigger.create({\n    trigger: shell,\n    start: \"top+=20% bottom\",\n    end: \"bottom-=20% top\",\n    onUpdate: ({ isActive, getVelocity }) => {\n      if (!isActive) {\n        pauseLoop();\n        return;\n      }\n\n      gsap.killTweensOf(heroLoop);\n\n      const scrollVelocity = getVelocity();\n      if (Math.abs(scrollVelocity) > 0.5) {\n        const scrollDirection = Math.sign(scrollVelocity);\n        const effectiveDirection = initialDirection < 0 ? -scrollDirection : scrollDirection;\n        currentDirection = effectiveDirection;\n\n        const boostAmount = Math.min(Math.abs(scrollVelocity * velocityMult), maxSpeed);\n        const effectiveSpeed = absBaseSpeed + (Math.abs(effectiveDirection) * boostAmount);\n\n        heroLoop.timeScale(effectiveSpeed * Math.sign(effectiveDirection));\n      }\n\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        gsap.to(heroLoop, {\n          timeScale: absBaseSpeed * Math.sign(currentDirection),\n          duration: 0.5,\n          ease: \"power1.out\",\n          overwrite: true\n        });\n      }, 150);\n    },\n    onLeave: pauseLoop,\n    onEnter: resumeLoop,\n    onLeaveBack: pauseLoop,\n    onEnterBack: resumeLoop\n  });\n\n  return () => {\n    clearTimeout(scrollTimeout);\n    try { st && st.kill && st.kill(); } catch (e) {}\n    gsap.killTweensOf(heroLoop);\n    try { heroLoop.kill && heroLoop.kill(); } catch (e) {}\n  };\n}\n\nfunction createVennCircles() {\n  const shell = document.querySelector('.venn-shell');\n  if (!shell) {\n    console.warn('.venn-shell not found — skipping venn init');\n    return;\n  }\n\n  // Get shell bounds to size SVG\n  const bounds = shell.getBoundingClientRect();\n  const width = Math.max(300, Math.round(bounds.width));\n  const height = Math.max(200, Math.round(bounds.height));\n\n  // Create SVG overlay positioned absolutely inside the shell\n  const svgNS = 'http://www.w3.org/2000/svg';\n  const svg = document.createElementNS(svgNS, 'svg');\n  svg.setAttribute('width', '100%');\n  svg.setAttribute('height', '100%');\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n  svg.style.position = 'absolute';\n  svg.style.left = '0';\n  svg.style.top = '0';\n  // ensure svg overlays above any canvas/video we insert\n  svg.style.zIndex = '2';\n  svg.style.pointerEvents = 'none';\n  svg.style.overflow = 'visible';\n\n  // Two circles: left and right\n  const left = document.createElementNS(svgNS, 'circle');\n  const right = document.createElementNS(svgNS, 'circle');\n\n  // Starting positions (percent-based inside viewBox) - push them further to the edges\n  const cxLeft = Math.round(width * 0.12);\n  const cxRight = Math.round(width * 0.88);\n  const cy = Math.round(height * 0.5);\n\n  // Compute base and target radius (make circles 15% smaller than base)\n  const baseR = Math.round(Math.min(width, height) * 0.38);\n  const targetR = Math.round(baseR * 0.85);\n\n  // Initial radius (debug = set to target so circles are visible immediately)\n  left.setAttribute('cx', cxLeft);\n  left.setAttribute('cy', cy);\n  left.setAttribute('r', targetR);\n  // pick colors based on shell/background luminance so debug visuals are visible\n  const bgColor = window.getComputedStyle(shell).backgroundColor || window.getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';\n  const pickColors = (bg) => {\n    // parse `rgb(a)?(...)`\n    try {\n      const nums = bg.replace(/[^0-9.,]/g, '').split(',').map(n => parseFloat(n));\n      const r = nums[0] || 255, g = nums[1] || 255, b = nums[2] || 255;\n      // relative luminance approximation\n      const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;\n      const darkBg = lum < 0.5;\n      // Use white outlines and a dotted stroke for both light and dark backgrounds.\n      // Small dots are achieved with a short dash length and spacing, plus round line caps.\n      if (darkBg) {\n  return { fill: 'rgba(255,255,255,0.06)', stroke: '#ffffff', lensFill: 'rgba(255,255,255,0.08)', strokeDash: '1 7', strokeW: 2 };\n      }\n  return { fill: 'rgba(0,100,255,0.12)', stroke: '#ffffff', lensFill: 'rgba(255,0,0,0.12)', strokeDash: '1 7', strokeW: 2 };\n    } catch (e) {\n  return { fill: 'rgba(0,100,255,0.12)', stroke: '#0366d6', lensFill: 'rgba(255,0,0,0.12)', strokeDash: '6 6', strokeW: 2 };\n    }\n  };\n  const colors = pickColors(bgColor);\n  // Do not fill the circles so they don't block the video — keep stroke for visual guide\n  left.setAttribute('fill', 'none');\n  left.setAttribute('stroke', colors.stroke);\n  left.setAttribute('stroke-dasharray', colors.strokeDash);\n  left.setAttribute('stroke-width', colors.strokeW);\n  // round caps make short dash lengths look like dots\n  left.setAttribute('stroke-linecap', 'round');\n  // make the outline 50% opaque\n  left.setAttribute('stroke-opacity', '0.8');\n\n  right.setAttribute('cx', cxRight);\n  right.setAttribute('cy', cy);\n  right.setAttribute('r', targetR);\n  right.setAttribute('fill', 'none');\n  right.setAttribute('stroke', colors.stroke);\n  right.setAttribute('stroke-dasharray', colors.strokeDash);\n  right.setAttribute('stroke-width', colors.strokeW);\n  // round caps make short dash lengths look like dots\n  right.setAttribute('stroke-linecap', 'round');\n  // make the outline 50% opaque\n  right.setAttribute('stroke-opacity', '0.8');\n\n  svg.appendChild(left);\n  svg.appendChild(right);\n\n  // Create defs & clipPath for the lens intersection and a path to hold it\n  const defs = document.createElementNS(svgNS, 'defs');\n  const clipPath = document.createElementNS(svgNS, 'clipPath');\n  clipPath.setAttribute('id', 'venn-clip');\n  clipPath.setAttribute('clipPathUnits', 'userSpaceOnUse');\n  const lensPath = document.createElementNS(svgNS, 'path');\n  lensPath.setAttribute('d', '');\n  // visible for debug; set to '#000' or 'none' for production\n  lensPath.setAttribute('fill', colors.lensFill || 'rgba(255,0,0,0.12)');\n  clipPath.appendChild(lensPath);\n  defs.appendChild(clipPath);\n  // Also create an SVG mask as a fallback — masks sometimes render where clipPath does not\n  const maskEl = document.createElementNS(svgNS, 'mask');\n  maskEl.setAttribute('id', 'venn-mask');\n  maskEl.setAttribute('maskUnits', 'userSpaceOnUse');\n  // a black rect background (masked-out area)\n  const maskBg = document.createElementNS(svgNS, 'rect');\n  maskBg.setAttribute('x', '0');\n  maskBg.setAttribute('y', '0');\n  maskBg.setAttribute('width', String(width));\n  maskBg.setAttribute('height', String(height));\n  maskBg.setAttribute('fill', '#000');\n  const maskPath = document.createElementNS(svgNS, 'path');\n  maskPath.setAttribute('d', '');\n  // white path shows through the mask\n  maskPath.setAttribute('fill', '#fff');\n  maskEl.appendChild(maskBg);\n  maskEl.appendChild(maskPath);\n  defs.appendChild(maskEl);\n  svg.appendChild(defs);\n\n  // Ensure the shell is positioned so the absolute SVG overlays correctly\n  const prevPosition = window.getComputedStyle(shell).position;\n  if (prevPosition === 'static' || !prevPosition) {\n    try { shell.style.position = 'relative'; } catch (e) {}\n  }\n\n  // Append svg to shell\n  shell.appendChild(svg);\n  _vennSVG = svg;\n\n  // Locate user-provided label shells (prefer existing DOM nodes created in Webflow)\n  let leftLabel = null;\n  let rightLabel = null;\n  try {\n    leftLabel = shell.querySelector('.venn-txt-shell-left');\n    rightLabel = shell.querySelector('.venn-txt-shell-right');\n    [leftLabel, rightLabel].forEach(el => {\n      if (!el) return;\n      try {\n        // ensure centering transform so (left,top) map the element's center to the coord\n        el.style.position = el.style.position || 'absolute';\n        el.style.transform = el.style.transform || 'translate(-50%,-50%)';\n        el.style.pointerEvents = 'none';\n        el.style.zIndex = el.style.zIndex || '3';\n      } catch (e) {}\n    });\n  } catch (e) {}\n\n  // Clone a page video into the shell (if present) to ensure we can apply clip/mask\n  try {\n    const pageVideo = document.querySelector('video');\n    if (pageVideo && !pageVideo.closest('.venn-shell')) {\n  const clone = pageVideo.cloneNode(true);\n  // Ensure autoplay will be permitted (muted) and attributes are explicit\n  try { clone.muted = true; } catch (e) {}\n  try { clone.setAttribute('muted', ''); } catch (e) {}\n  try { clone.autoplay = true; } catch (e) {}\n  try { clone.setAttribute('autoplay', ''); } catch (e) {}\n  try { clone.loop = true; } catch (e) {}\n  try { clone.setAttribute('loop', ''); } catch (e) {}\n  try { clone.playsInline = true; } catch (e) {}\n  try { clone.setAttribute('playsinline', ''); } catch (e) {}\n  try { clone.setAttribute('preload', 'auto'); } catch (e) {}\n  clone.style.position = 'absolute';\n  clone.style.left = '0';\n  clone.style.top = '0';\n  clone.style.width = '100%';\n  clone.style.height = '100%';\n  clone.style.objectFit = 'cover';\n  clone.style.zIndex = '1';\n  clone.style.pointerEvents = 'none';\n  clone.style.opacity = '1';\n  try { shell.insertBefore(clone, svg); } catch (e) { shell.appendChild(clone); }\n  // Try to start playback; some browsers require play() call even if autoplay attribute present\n  try { const p = clone.play(); if (p && p.catch) p.catch(() => {}); } catch (e) {}\n  _vennClonedVideo = clone;\n      // Try to start the original page video as well (may be the source)\n      try {\n        const p = pageVideo.play();\n        if (p && p.catch) p.catch(() => {\n          // try muting and playing again\n          try { pageVideo.muted = true; pageVideo.setAttribute('muted',''); } catch (e) {}\n          try { pageVideo.play().catch(() => {}); } catch (e) {}\n        });\n      } catch (e) {}\n      // ensure the clone plays\n      try { const p2 = clone.play(); if (p2 && p2.catch) p2.catch(() => {}); } catch (e) {}\n      // if autoplay is blocked, resume on first user interaction\n      const ensurePlay = (v) => {\n        try { v.play().catch(() => {}); } catch (e) {}\n      };\n      const resumeOnGesture = () => {\n        try { ensurePlay(pageVideo); ensurePlay(clone); } catch (e) {}\n      };\n      document.addEventListener('click', resumeOnGesture, { once: true });\n    }\n  } catch (e) {}\n\n  // Canvas fallback: draw frames from an existing video (inside shell) into a canvas\n  try {\n  const pageVid = shell.querySelector('video');\n    if (pageVid) {\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      canvas.style.position = 'absolute';\n      canvas.style.left = '0';\n      canvas.style.top = '0';\n      canvas.style.width = '100%';\n      canvas.style.height = '100%';\n      canvas.style.zIndex = '1';\n      canvas.style.pointerEvents = 'none';\n      try { shell.insertBefore(canvas, svg); } catch (e) { shell.appendChild(canvas); }\n      _vennCanvas = canvas;\n      const ctx = canvas.getContext('2d');\n      // Ensure the shell video is playing; try to play and fallback to muting if blocked\n      try {\n        const playPromise = pageVid.play();\n        if (playPromise && playPromise.catch) playPromise.catch(() => {\n          try { pageVid.muted = true; pageVid.setAttribute('muted',''); } catch (e) {}\n          try { pageVid.play().catch(() => {}); } catch (e) {}\n        });\n      } catch (e) {}\n      document.addEventListener('click', () => { try { pageVid.play().catch(() => {}); } catch (e) {} }, { once: true });\n      // draw loop: compute a minimal scale so the drawn video fully covers the lens\n      const draw = () => {\n        try {\n          if (pageVid && pageVid.readyState >= 2) {\n            ctx.clearRect(0,0,canvas.width,canvas.height);\n            const vw = pageVid.videoWidth || pageVid.clientWidth || canvas.width;\n            const vh = pageVid.videoHeight || pageVid.clientHeight || canvas.height;\n            // compute minimal scale from lens polygon bbox so we don't reveal edges\n            let autoScale = 0.75; // fallback default\n            try {\n              const poly = lensPolygonPoints(params.lx, params.cy, params.lr, params.rx, params.cy, params.rr, 28);\n              if (poly && poly.length) {\n                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n                for (let p of poly) {\n                  if (p.x < minX) minX = p.x;\n                  if (p.y < minY) minY = p.y;\n                  if (p.x > maxX) maxX = p.x;\n                  if (p.y > maxY) maxY = p.y;\n                }\n                const bboxW = Math.max(1, (maxX - minX));\n                const bboxH = Math.max(1, (maxY - minY));\n                const minScaleW = bboxW / canvas.width;\n                const minScaleH = bboxH / canvas.height;\n                const minScale = Math.max(minScaleW, minScaleH);\n                // add a small safety margin to avoid crisp-edge reveals\n                autoScale = Math.min(1, minScale * 1.03);\n                // ensure not tiny\n                autoScale = Math.max(autoScale, 0.2);\n              }\n            } catch (e) {\n              autoScale = 0.75;\n            }\n            const destW = Math.round(canvas.width * autoScale);\n            const destH = Math.round(canvas.height * autoScale);\n            const dx = Math.round((canvas.width - destW) / 2);\n            const dy = Math.round((canvas.height - destH) / 2);\n            try {\n              ctx.drawImage(pageVid, 0, 0, vw, vh, dx, dy, destW, destH);\n            } catch (e) {\n              // fallback to simple draw if dimension mapping fails\n              try { ctx.drawImage(pageVid, dx, dy, destW, destH); } catch (e) {}\n            }\n          }\n        } catch (e) {}\n        _vennCanvasRAF = requestAnimationFrame(draw);\n      };\n      _vennCanvasRAF = requestAnimationFrame(draw);\n    }\n  } catch (e) {}\n\n  // Visible debug overlay (helps when console is muted globally)\n  const DEBUG_OVLY = false; // set true to enable\n  let debugEl = null;\n  if (DEBUG_OVLY) {\n    debugEl = document.createElement('div');\n    debugEl.style.position = 'absolute';\n  debugEl.style.right = '12px';\n  // move below the site's nav/header so text isn't obscured\n  debugEl.style.top = '80px';\n  debugEl.style.padding = '6px 8px';\n  debugEl.style.background = 'rgba(0,0,0,0.65)';\n  debugEl.style.color = '#fff';\n  debugEl.style.fontFamily = 'monospace';\n  debugEl.style.fontSize = '11px';\n  debugEl.style.zIndex = 9999;\n  debugEl.style.pointerEvents = 'none';\n  debugEl.style.whiteSpace = 'pre-wrap';\n  debugEl.style.maxWidth = 'calc(100% - 160px)';\n  debugEl.style.overflow = 'hidden';\n  debugEl.textContent = 'venn: initializing...';\n    // append to shell (not svg) so HTML can render\n    try { shell.appendChild(debugEl); } catch (e) {}\n  }\n\n  // Target radius is computed above (baseR/targetR) and used for params\n\n  // Build a timeline controlled by scroll\n  // Since the shell is full-viewport (100vh), when its top reaches the top of the\n  // viewport it is fully visible. Pin it there and run the animation while pinned.\n  const tl = gsap.timeline({\n    scrollTrigger: {\n      trigger: shell,\n      start: 'top top',    // start when shell is fully in view (top aligned)\n      end: '+=100%',       // pin for one viewport worth of scrolling\n      pin: true,\n      // Scrub the timeline so the animation progress follows the user's scroll\n      scrub: 0.6,\n      markers: false\n    }\n  });\n  // Param object we will animate (and use to update circles + lens)\n  // We'll keep radii constant and animate only horizontal positions so circles slide toward each other\n  const params = {\n    lx: cxLeft,\n    rx: cxRight,\n    cy: cy,\n    lr: targetR,\n    rr: targetR\n  };\n\n  // distance in pixels between the visible stroke and the video mask\n  const maskCushion = 2;\n\n  const updateShapes = () => {\n    try {\n      left.setAttribute('cx', Math.round(params.lx));\n      left.setAttribute('cy', Math.round(params.cy));\n      left.setAttribute('r', Math.round(params.lr));\n      right.setAttribute('cx', Math.round(params.rx));\n      right.setAttribute('cy', Math.round(params.cy));\n      right.setAttribute('r', Math.round(params.rr));\n\n      // Position HTML labels (if present) to the circle centers. We map viewBox\n      // coordinates -> percent so absolutely-positioned divs inside `shell` align.\n      try {\n        if (leftLabel) {\n          leftLabel.style.left = `${(params.lx / width * 100).toFixed(4)}%`;\n          leftLabel.style.top = `${(params.cy / height * 100).toFixed(4)}%`;\n        }\n        if (rightLabel) {\n          rightLabel.style.left = `${(params.rx / width * 100).toFixed(4)}%`;\n          rightLabel.style.top = `${(params.cy / height * 100).toFixed(4)}%`;\n        }\n      } catch (e) {}\n\n  // compute lens path and set it on lensPath\n  // shrink the radii by half the stroke width plus a small cushion so the dotted\n  // stroke does not overlap the revealed video area.\n  const insetLr = Math.max(0, params.lr - ((colors && colors.strokeW ? colors.strokeW : 2) / 2) - maskCushion);\n  const insetRr = Math.max(0, params.rr - ((colors && colors.strokeW ? colors.strokeW : 2) / 2) - maskCushion);\n  const d = lensPathForCircles(params.lx, params.cy, insetLr, params.rx, params.cy, insetRr);\n      lensPath.setAttribute('d', d || '');\n\n      // apply clipPath to the .venn-video-shell parent (more robust with background-cover videos)\n      const videoShellEl = document.querySelector('.venn-video-shell');\n      const videoEl = videoShellEl ? videoShellEl.querySelector('video') : null;\n      // find the deepest visible element that likely contains the visual (video or background-image)\n      const findVisualTarget = (root) => {\n        if (!root) return null;\n        // prefer an actual video element\n        const vid = root.querySelector('video');\n        if (vid) return vid;\n        // if the root itself has a background image, use it\n        try {\n          const csRoot = getComputedStyle(root);\n          if (csRoot && csRoot.backgroundImage && csRoot.backgroundImage !== 'none') return root;\n        } catch (e) {}\n        // otherwise search children for a background image\n        const walker = root.querySelectorAll('*');\n        for (let i = 0; i < walker.length; i++) {\n          try {\n            const el = walker[i];\n            const cs = getComputedStyle(el);\n            if (cs && cs.backgroundImage && cs.backgroundImage !== 'none') return el;\n          } catch (e) {}\n        }\n        return root;\n      };\n  // Prefer the canvas as the visual target if it exists (we draw frames there)\n  const visualTarget = _vennCanvas || findVisualTarget(videoShellEl) || videoShellEl;\n      // prefer a full-URL reference which is more reliable across browsers\n      const frag = '#venn-clip';\n      const localRef = `url(${frag})`;\n      const fullRef = (() => {\n        try { return `url(${location.href.replace(/#.*$/, '')}${frag})`; } catch (e) { return localRef; }\n      })();\n\n      const applyRef = (el) => {\n        try {\n          el.style.clipPath = fullRef;\n          el.style.webkitClipPath = fullRef;\n          // also try the local ref as a fallback\n          // some browsers accept one or the other\n          // (setting both is fine)\n          el.style.clipPath = el.style.clipPath || localRef;\n          el.style.webkitClipPath = el.style.webkitClipPath || localRef;\n          el.style.overflow = 'hidden';\n        } catch (e) {}\n      };\n\n      // Apply clip/mask to the visual target (video element or background element)\n      if (visualTarget) {\n        applyRef(visualTarget);\n      }\n\n      // Update the mask path so we can apply an SVG mask as a fallback\n      try {\n        const dStr = lensPath.getAttribute('d') || '';\n        // set mask path\n        try { maskPath.setAttribute('d', dStr || ''); } catch (e) {}\n        if (dStr) {\n          // also try CSS path() fallback for clipPath\n          const cssPath = `path('${dStr.replace(/'/g, \"\\\\'\")}')`;\n          if (videoShellEl) {\n            try { videoShellEl.style.clipPath = cssPath; videoShellEl.style.webkitClipPath = cssPath; } catch (e) {}\n          }\n          if (videoEl) {\n            try { videoEl.style.clipPath = cssPath; videoEl.style.webkitClipPath = cssPath; } catch (e) {}\n          }\n        }\n      } catch (e) {}\n\n      // As an additional, highly-compatible fallback: approximate the lens with a polygon\n      // and apply via CSS `clip-path: polygon(...)` which you noted worked from Webflow.\n      try {\n        // use the inset radii so the polygon mask sits inside the stroke by maskCushion\n        const polyLr = Math.max(0, params.lr - ((colors && colors.strokeW ? colors.strokeW : 2) / 2) - maskCushion);\n        const polyRr = Math.max(0, params.rr - ((colors && colors.strokeW ? colors.strokeW : 2) / 2) - maskCushion);\n        const polygonPoints = lensPolygonPoints(params.lx, params.cy, polyLr, params.rx, params.cy, polyRr, 24);\n        if (polygonPoints && polygonPoints.length) {\n          // convert to percent coordinates relative to the svg/viewBox width/height\n              const polyStr = polygonPoints.map(p => `${(p.x / width * 100).toFixed(3)}% ${(p.y / height * 100).toFixed(3)}%`).join(', ');\n          try { visualTarget.style.clipPath = `polygon(${polyStr})`; visualTarget.style.webkitClipPath = `polygon(${polyStr})`; } catch (e) {}\n        }\n      } catch (e) {}\n\n      // Apply the SVG mask (url) as a final fallback — some browsers support masks better\n      try {\n        const maskFrag = '#venn-mask';\n        const fullMaskRef = `url(${location.href.replace(/#.*$/, '')}${maskFrag})`;\n        if (videoShellEl) {\n          try { videoShellEl.style.mask = fullMaskRef; videoShellEl.style.webkitMask = fullMaskRef; } catch (e) {}\n        }\n        if (videoEl) {\n          try { videoEl.style.mask = fullMaskRef; videoEl.style.webkitMask = fullMaskRef; } catch (e) {}\n        }\n      } catch (e) {}\n\n      // Update visible debug overlay (useful if console logs are muted)\n      try {\n        if (debugEl) {\n          const dStr = lensPath.getAttribute('d') || '';\n          const shellClip = videoShellEl ? (getComputedStyle(videoShellEl).clipPath || getComputedStyle(videoShellEl).webkitClipPath || 'none') : 'n/a';\n          const vidClip = videoEl ? (getComputedStyle(videoEl).clipPath || getComputedStyle(videoEl).webkitClipPath || 'none') : 'n/a';\n          const newText = `lens:${dStr? 'yes':'no'} len:${dStr.length}\\nclipShell:${shellClip}\\nclipVideo:${vidClip}\\nfullRef:${fullRef}\\nvideoEl:${!!videoEl}\\nclone:${!!_vennClonedVideo}`;\n          if (newText !== lastDebugText) {\n            debugEl.textContent = newText;\n            lastDebugText = newText;\n          }\n        }\n      } catch (e) {}\n    } catch (e) {}\n  };\n\n  // Animate params so circles slide horizontally toward each other while the\n  // container is pinned. We want a 22% overlap of the circles' diameter.\n  // For equal radii r, overlap_distance = 0.22 * (2r) = 0.44r\n  // center_distance = 2r - overlap_distance = 1.56r\n  const finalCenterDistance = 1.56 * targetR;\n  const centerX = width / 2;\n  const finalLx = Math.round(centerX - (finalCenterDistance / 2));\n  const finalRx = Math.round(centerX + (finalCenterDistance / 2));\n\n  tl.to(params, { lx: finalLx, duration: 1.2, ease: 'power2.out', onUpdate: updateShapes }, 0);\n  tl.to(params, { rx: finalRx, duration: 1.2, ease: 'power2.out', onUpdate: updateShapes }, 0);\n\n  // If the page includes an element that should appear on top of the video\n  // inside the lens (class `.venn-vid-txt`), animate its blur from 20px -> 0\n  // starting when the circles first begin to overlap. We compute the relative\n  // fraction of the params animation where overlap starts and insert a scrubbed\n  // tween into the same timeline so it follows the scroll scrub.\n  try {\n    const vidTxt = shell.querySelector('.venn-vid-txt');\n    if (vidTxt) {\n      // use GSAP to set initial state (clean and performant)\n      try { gsap.set(vidTxt, { filter: 'blur(20px)', opacity: 0, willChange: 'filter,opacity' }); } catch (e) {}\n      // compute fraction where the circles begin to overlap (center distance < sum of radii)\n      const initialDist = cxRight - cxLeft;\n      const finalDist = finalRx - finalLx;\n      const rSum = params.lr + params.rr;\n      if (Math.abs(finalDist - initialDist) > 0.0001) {\n        let frac = (rSum - initialDist) / (finalDist - initialDist);\n        frac = Math.max(0, Math.min(1, frac));\n        const tlDur = tl.duration() || 1.2;\n  // start slightly earlier so the reveal begins before overlap; tweakable\n  const earlyFraction = 0.45; // start 70% of timeline earlier\n        let startTime = frac * tlDur - (earlyFraction * tlDur);\n        startTime = Math.max(0, startTime);\n        const remaining = Math.max(0.001, tlDur - startTime);\n        try {\n          // use fromTo so both filter and opacity are driven together and rendered by GSAP\n          tl.fromTo(vidTxt,\n            { filter: 'blur(20px)', opacity: 0 },\n            { filter: 'blur(0px)', opacity: 1, duration: remaining, ease: 'none' },\n            startTime\n          );\n        } catch (e) {}\n      }\n    }\n  } catch (e) {}\n\n  // Animate the venn-sub-txt elements (left and right side text)\n  // using SplitText to fade/blur in from bottom after circles finish joining\n  try {\n    const subTextElements = shell.querySelectorAll('.venn-sub-txt');\n    if (subTextElements.length > 0) {\n      const tlDur = tl.duration() || 1.2;\n      // Start the text animation after circles are fully overlapped (100% through)\n      const textStartTime = tlDur * 1.0; // Start at 100% through the animation\n      const textDuration = tlDur * 0.4; // Use 40% of timeline for text animation\n      \n      subTextElements.forEach(textEl => {\n        // Split the text into words\n        const split = new SplitText(textEl, { type: 'words' });\n        \n        // Set initial state: invisible, blurred, and shifted down\n        gsap.set(split.words, {\n          opacity: 0,\n          filter: 'blur(10px)',\n          y: 15\n        });\n        \n        // Animate words in from bottom with blur fade\n        tl.to(split.words, {\n          opacity: 1,\n          filter: 'blur(0px)',\n          y: 0,\n          duration: textDuration,\n          stagger: 0.09,\n          ease: 'power2.out'\n        }, textStartTime);\n      });\n      \n      // Extend the pin duration to give users time to read\n      if (tl.scrollTrigger) {\n        tl.scrollTrigger.vars.end = '+=200%'; // Increased from 100% to 200%\n        tl.scrollTrigger.refresh();\n      }\n    }\n  } catch (e) {\n    console.error('Error setting up venn-sub-txt animation:', e);\n  }\n\n  // initialize\n  updateShapes();\n\n  _vennTL = tl;\n}\n\n// Compute SVG path string for the lens (intersection) of two circles\nfunction lensPathForCircles(x1, y1, r1, x2, y2, r2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const d = Math.hypot(dx, dy);\n  if (d <= 0.0001) return '';\n  // no intersection\n  if (d >= r1 + r2) return '';\n  // one circle inside another -> return the smaller circle path\n  if (d <= Math.abs(r1 - r2)) {\n    const r = Math.min(r1, r2);\n    const cx = r1 < r2 ? x1 : x2;\n    const cy = r1 < r2 ? y1 : y2;\n    return circlePath(cx, cy, r);\n  }\n\n  // intersection points\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));\n  const xm = x1 + (a * dx) / d;\n  const ym = y1 + (a * dy) / d;\n  const rx = -dy * (h / d);\n  const ry = dx * (h / d);\n  const xi1 = xm + rx;\n  const yi1 = ym + ry;\n  const xi2 = xm - rx;\n  const yi2 = ym - ry;\n\n  // Build path: arc on circle1 from P1 to P2, then arc on circle2 from P2 back to P1\n  const largeArc1 = 0;\n  const sweep1 = 1;\n  const largeArc2 = 0;\n  const sweep2 = 1;\n\n  // Use absolute coords\n  const path = `M ${xi1} ${yi1} ` +\n    `A ${r1} ${r1} 0 ${largeArc1} ${sweep1} ${xi2} ${yi2} ` +\n    `A ${r2} ${r2} 0 ${largeArc2} ${sweep2} ${xi1} ${yi1} Z`;\n  return path;\n}\n\nfunction circlePath(cx, cy, r) {\n  // draw a full circle as path\n  return `M ${cx - r} ${cy} ` +\n    `a ${r} ${r} 0 1 0 ${r * 2} 0 ` +\n    `a ${r} ${r} 0 1 0 ${-r * 2} 0 Z`;\n}\n\n// Approximate the lens intersection area by sampling points along both arcs\nfunction lensPolygonPoints(x1, y1, r1, x2, y2, r2, segments = 24) {\n  // if no intersection, return empty\n  const dx = x2 - x1; const dy = y2 - y1; const d = Math.hypot(dx, dy);\n  if (d <= 0.0001) return [];\n  if (d >= r1 + r2) return [];\n  if (d <= Math.abs(r1 - r2)) {\n    // return circle approximated\n    const r = Math.min(r1, r2);\n    const cx = r1 < r2 ? x1 : x2;\n    const cy = r1 < r2 ? y1 : y2;\n    const pts = [];\n    for (let i = 0; i < segments; i++) {\n      const a = (i / segments) * Math.PI * 2;\n      pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });\n    }\n    return pts;\n  }\n\n  // compute intersection arc endpoints (reuse math from lensPathForCircles)\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));\n  const xm = x1 + (a * dx) / d; const ym = y1 + (a * dy) / d;\n  const rx = -dy * (h / d); const ry = dx * (h / d);\n  const xi1 = xm + rx; const yi1 = ym + ry;\n  const xi2 = xm - rx; const yi2 = ym - ry;\n\n  // angles for arcs\n  const ang1 = Math.atan2(yi1 - y1, xi1 - x1);\n  const ang2 = Math.atan2(yi2 - y1, xi2 - x1);\n  const ang3 = Math.atan2(yi2 - y2, xi2 - x2);\n  const ang4 = Math.atan2(yi1 - y2, xi1 - x2);\n\n  // normalize sweep from ang1 -> ang2 on circle1, and ang3 -> ang4 on circle2\n  const pts = [];\n  const segHalf = Math.ceil(segments / 2);\n  // circle1 arc from ang1 to ang2\n  for (let i = 0; i <= segHalf; i++) {\n    const t = i / segHalf;\n    // interpolate angle on shorter arc\n    let a1 = ang1 + shortestAngleDiff(ang1, ang2) * t;\n    pts.push({ x: x1 + Math.cos(a1) * r1, y: y1 + Math.sin(a1) * r1 });\n  }\n  // circle2 arc from ang3 to ang4\n  for (let i = 0; i <= segHalf; i++) {\n    const t = i / segHalf;\n    let a2 = ang3 + shortestAngleDiff(ang3, ang4) * t;\n    pts.push({ x: x2 + Math.cos(a2) * r2, y: y2 + Math.sin(a2) * r2 });\n  }\n  return pts;\n}\n\nfunction shortestAngleDiff(a, b) {\n  let diff = b - a;\n  while (diff < -Math.PI) diff += Math.PI * 2;\n  while (diff > Math.PI) diff -= Math.PI * 2;\n  return diff;\n}","import gsap from 'gsap';\n\n/*\nThis helper function makes a group of elements animate along the x-axis in a seamless, responsive loop.\n\nFeatures:\n - Uses xPercent so that even if the widths change (like if the window gets resized), it should still work in most cases.\n - When each item animates to the left or right enough, it will loop back to the other side\n - Optionally pass in a config object with values like \"speed\" (default: 1, which travels at roughly 100 pixels per second), paused (boolean),  repeat, reversed, and paddingRight.\n - The returned timeline will have the following methods added to it:\n   - next() - animates to the next element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.\n   - previous() - animates to the previous element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.\n   - toIndex() - pass in a zero-based index value of the element that it should animate to, and optionally pass in a vars object to control duration, easing, etc. Always goes in the shortest direction\n   - current() - returns the current index (if an animation is in-progress, it reflects the final index)\n   - times - an Array of the times on the timeline where each element hits the \"starting\" spot. There's also a label added accordingly, so \"label1\" is when the 2nd element reaches the start.\n */\nexport default function horizontalLoop(items, config) {\n  items = gsap.utils.toArray(items);\n  config = config || {};\n  let tl = gsap.timeline({\n      repeat: config.repeat,\n      paused: config.paused,\n      defaults: { ease: 'none' },\n      onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100),\n    }),\n    length = items.length,\n    startX = items[0].offsetLeft,\n    times = [],\n    widths = [],\n    xPercents = [],\n    curIndex = 0,\n    pixelsPerSecond = (config.speed || 1) * 100,\n    snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1), // some browsers shift by a pixel to accommodate flex layouts, so for example if width is 20% the first element's width might be 242px, and the next 243px, alternating back and forth. So we snap to 5 percentage points to make things look more natural\n    totalWidth,\n    curX,\n    distanceToStart,\n    distanceToLoop,\n    item,\n    i;\n  gsap.set(items, {\n    // convert \"x\" to \"xPercent\" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.\n    xPercent: (i, el) => {\n      let w = (widths[i] = parseFloat(gsap.getProperty(el, 'width', 'px')));\n      xPercents[i] = snap(\n        (parseFloat(gsap.getProperty(el, 'x', 'px')) / w) * 100 +\n          gsap.getProperty(el, 'xPercent')\n      );\n      return xPercents[i];\n    },\n  });\n  gsap.set(items, { x: 0 });\n  totalWidth =\n    items[length - 1].offsetLeft +\n    (xPercents[length - 1] / 100) * widths[length - 1] -\n    startX +\n    items[length - 1].offsetWidth *\n      gsap.getProperty(items[length - 1], 'scaleX') +\n    (parseFloat(config.paddingRight) || 0);\n  for (i = 0; i < length; i++) {\n    item = items[i];\n    curX = (xPercents[i] / 100) * widths[i];\n    distanceToStart = item.offsetLeft + curX - startX;\n    distanceToLoop =\n      distanceToStart + widths[i] * gsap.getProperty(item, 'scaleX');\n    tl.to(\n      item,\n      {\n        xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),\n        duration: distanceToLoop / pixelsPerSecond,\n      },\n      0\n    )\n      .fromTo(\n        item,\n        {\n          xPercent: snap(\n            ((curX - distanceToLoop + totalWidth) / widths[i]) * 100\n          ),\n        },\n        {\n          xPercent: xPercents[i],\n          duration:\n            (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,\n          immediateRender: false,\n        },\n        distanceToLoop / pixelsPerSecond\n      )\n      .add('label' + i, distanceToStart / pixelsPerSecond);\n    times[i] = distanceToStart / pixelsPerSecond;\n  }\n  function toIndex(index, vars) {\n    vars = vars || {};\n    Math.abs(index - curIndex) > length / 2 &&\n      (index += index > curIndex ? -length : length); // always go in the shortest direction\n    let newIndex = gsap.utils.wrap(0, length, index),\n      time = times[newIndex];\n    if (time > tl.time() !== index > curIndex) {\n      // if we're wrapping the timeline's playhead, make the proper adjustments\n      vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };\n      time += tl.duration() * (index > curIndex ? 1 : -1);\n    }\n    curIndex = newIndex;\n    vars.overwrite = true;\n    return tl.tweenTo(time, vars);\n  }\n  tl.next = (vars) => toIndex(curIndex + 1, vars);\n  tl.previous = (vars) => toIndex(curIndex - 1, vars);\n  tl.current = () => curIndex;\n  tl.toIndex = (index, vars) => toIndex(index, vars);\n  tl.times = times;\n  tl.progress(1, true).progress(0, true); // pre-render for performance\n  if (config.reversed) {\n    tl.vars.onReverseComplete();\n    tl.reverse();\n  }\n  return tl;\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$ea646a5b18efb62a$export$a71079573851442d","$ea646a5b18efb62a$export$ed43c5b1eb9a3fd6","$2bvox","$hR2D0","$gkx87","$64aKy","gsap","registerPlugin","ScrollTrigger","SplitText","$ea646a5b18efb62a$var$_vennSVG","$ea646a5b18efb62a$var$_vennTL","$ea646a5b18efb62a$var$_vennClonedVideo","$ea646a5b18efb62a$var$_vennCanvas","$ea646a5b18efb62a$var$_vennCanvasRAF","$ea646a5b18efb62a$var$createVennCircles","shell","document","querySelector","console","warn","bounds","getBoundingClientRect","width","Math","max","round","height","svgNS","svg","createElementNS","setAttribute","style","position","left","top","zIndex","pointerEvents","overflow","right","cxLeft","cxRight","cy","targetR","baseR","min","bgColor","window","getComputedStyle","backgroundColor","body","colors","pickColors","bg","nums","replace","split","map","parseFloat","r","g","b","lum","fill","stroke","lensFill","strokeDash","strokeW","appendChild","defs","clipPath","lensPath","maskEl","maskBg","String","maskPath","prevPosition","leftLabel","rightLabel","forEach","el","transform","pageVideo","closest","clone","cloneNode","muted","autoplay","loop","playsInline","objectFit","opacity","insertBefore","p","play","catch","p2","ensurePlay","addEventListener","once","pageVid","canvas","createElement","ctx","getContext","playPromise","draw","readyState","clearRect","vw","videoWidth","clientWidth","vh","videoHeight","clientHeight","autoScale","poly","$ea646a5b18efb62a$var$lensPolygonPoints","params","lx","lr","rx","rr","length","minX","Infinity","minY","maxX","maxY","x","y","bboxW","bboxH","minScaleW","minScaleH","minScale","destW","destH","dx","dy","drawImage","requestAnimationFrame","tl","timeline","scrollTrigger","trigger","start","end","pin","scrub","markers","updateShapes","toFixed","insetLr","insetRr","d","$ea646a5b18efb62a$var$lensPathForCircles","x1","y1","r1","x2","y2","r2","hypot","abs","cx","a","h","sqrt","xm","ym","ry","xi1","yi1","videoShellEl","videoEl","visualTarget","findVisualTarget","root","vid","csRoot","backgroundImage","walker","querySelectorAll","i","cs","frag","localRef","fullRef","location","href","applyRef","webkitClipPath","dStr","getAttribute","cssPath","polyLr","polyRr","polygonPoints","polyStr","join","fullMaskRef","mask","webkitMask","finalCenterDistance","centerX","finalLx","finalRx","to","duration","ease","onUpdate","vidTxt","filter","willChange","initialDist","finalDist","rSum","frac","tlDur","startTime","earlyFraction","remaining","fromTo","subTextElements","textStartTime","textDuration","textEl","type","words","stagger","vars","refresh","error","scienceTickerCleanups","index","txts","candidates","children","Array","from","tag","tagName","toLowerCase","txt","textContent","trim","debug","cleanup","$ea646a5b18efb62a$var$introTicker","txtNodes","initialDirection","scrollTimeout","heroLoop","default","repeat","speed","reversed","absBaseSpeed","timeScale","currentDirection","pauseLoop","killTweensOf","pause","resumeLoop","resume","st","create","isActive","getVelocity","scrollVelocity","scrollDirection","sign","effectiveDirection","effectiveSpeed","clearTimeout","setTimeout","overwrite","onLeave","onEnter","onLeaveBack","onEnterBack","kill","push","_scienceTickerCleanup","fn","parentNode","removeChild","cancelAnimationFrame","segments","pts","PI","cos","sin","xi2","yi2","ang1","atan2","ang2","ang3","ang4","segHalf","ceil","t","a1","$ea646a5b18efb62a$var$shortestAngleDiff","a2","diff","initPageTransitions","$46ab747bac60427b$export$2e2bcd8739ae039","items","config","utils","toArray","paused","defaults","onReverseComplete","totalTime","rawTime","startX","offsetLeft","times","widths","xPercents","curIndex","pixelsPerSecond","snap","totalWidth","curX","distanceToStart","distanceToLoop","item","xPercent","w","getProperty","offsetWidth","paddingRight","immediateRender","add","toIndex","newIndex","wrap","time","modifiers","tweenTo","next","previous","current","progress","reverse"],"version":3,"file":"formula.925b5d0f.js.map"}