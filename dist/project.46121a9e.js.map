{"mappings":"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","sources":["<anon>","src/scripts/project.js","src/scripts/utils/workLinksModule.js"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire60dc\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"1UEDz\", function(module, exports) {\n\n$parcel$export(module.exports, \"cleanupProjectPage\", () => $164a8b1918bfc2fb$export$1beac54aeac6904a);\n$parcel$export(module.exports, \"initProjectPage\", () => $164a8b1918bfc2fb$export$95e8c3fdd1a52149);\n\nvar $2bvox = parcelRequire(\"2bvox\");\n\nvar $hR2D0 = parcelRequire(\"hR2D0\");\n\nvar $gkx87 = parcelRequire(\"gkx87\");\n\nvar $cu1VQ = parcelRequire(\"cu1VQ\");\nlet $164a8b1918bfc2fb$var$projectScrollTriggers = [];\nlet $164a8b1918bfc2fb$var$scrollCtaTimeline = null;\nlet $164a8b1918bfc2fb$var$workLinksModule = null;\nfunction $164a8b1918bfc2fb$export$1beac54aeac6904a() {\n    // Kill any ScrollTrigger instances for this page\n    $164a8b1918bfc2fb$var$projectScrollTriggers.forEach((t)=>t && t.kill && t.kill());\n    $164a8b1918bfc2fb$var$projectScrollTriggers = [];\n    // Kill CTA timeline if it exists to avoid duplicate timelines after navigation\n    if ($164a8b1918bfc2fb$var$scrollCtaTimeline) {\n        try {\n            $164a8b1918bfc2fb$var$scrollCtaTimeline.kill && $164a8b1918bfc2fb$var$scrollCtaTimeline.kill();\n        } catch (e) {}\n        try {\n            $164a8b1918bfc2fb$var$scrollCtaTimeline.pause && $164a8b1918bfc2fb$var$scrollCtaTimeline.pause();\n        } catch (e) {}\n        $164a8b1918bfc2fb$var$scrollCtaTimeline = null;\n    }\n    // Cleanup work-links module\n    if ($164a8b1918bfc2fb$var$workLinksModule) {\n        $164a8b1918bfc2fb$var$workLinksModule.cleanup();\n        $164a8b1918bfc2fb$var$workLinksModule = null;\n    }\n}\n(0, $2bvox.gsap).registerPlugin((0, $hR2D0.ScrollTrigger), (0, $gkx87.SplitText));\nfunction $164a8b1918bfc2fb$export$95e8c3fdd1a52149() {\n    // initProjectPage called\n    const run = ()=>{\n        $164a8b1918bfc2fb$export$1beac54aeac6904a();\n        // Ensure page is at top on initial run (fix preserved scroll on refresh)\n        try {\n            console.log('[project] initProjectPage: attempting robust scroll reset');\n            const tryReset = ()=>{\n                try {\n                    if (typeof window !== 'undefined' && window._smootherInstance && typeof window._smootherInstance.scrollTo === 'function') {\n                        window._smootherInstance.scrollTo(0, false);\n                        return true;\n                    }\n                } catch (e) {}\n                try {\n                    window.scrollTo(0, 0);\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            };\n            // immediate attempt\n            tryReset();\n            // after paint (double rAF)\n            requestAnimationFrame(()=>requestAnimationFrame(()=>tryReset()));\n            // short timeout in case smoother initializes slightly later\n            setTimeout(()=>{\n                tryReset();\n                // After scroll reset, aggressively hide indicators\n                const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n                if (indicatorShells.length) try {\n                    (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                    (0, $2bvox.gsap).set(indicatorShells, {\n                        x: -150,\n                        autoAlpha: 0\n                    });\n                } catch (e) {}\n            }, 120);\n            // final attempt on full load (once)\n            const onLoad = ()=>{\n                tryReset();\n                // After scroll reset on load, aggressively hide indicators\n                const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n                if (indicatorShells.length) try {\n                    (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                    (0, $2bvox.gsap).set(indicatorShells, {\n                        x: -150,\n                        autoAlpha: 0\n                    });\n                } catch (e) {}\n                window.removeEventListener('load', onLoad);\n            };\n            try {\n                window.addEventListener('load', onLoad);\n            } catch (e) {}\n        } catch (e) {}\n        const isProjectPage = window.location.pathname.includes('/projects');\n        if (!isProjectPage) return;\n        // Set initial states separately (only if elements exist to avoid GSAP warnings)\n        const preCtaLine = document.querySelector('.scroll-cta-line');\n        const preCtaTxt = document.querySelector('.scroll-cta-txt');\n        if (preCtaTxt) (0, $2bvox.gsap).set(preCtaTxt, {\n            opacity: 1\n        });\n        if (preCtaLine) (0, $2bvox.gsap).set(preCtaLine, {\n            opacity: 1,\n            scaleY: 0,\n            transformOrigin: 'top center'\n        });\n        // Delay creation to ensure DOM is ready and element exists\n        setTimeout(()=>{\n            const ctaLine = document.querySelector('.scroll-cta-line');\n            const ctaTxt = document.querySelector('.scroll-cta-txt');\n            if (!ctaLine || !ctaTxt) // CTA elements not found; skipping CTA timeline\n            return;\n            // create/replace module-scoped CTA timeline\n            $164a8b1918bfc2fb$var$scrollCtaTimeline = (0, $2bvox.gsap).timeline({\n                repeat: -1,\n                defaults: {\n                    duration: 1,\n                    ease: \"expo.inOut\"\n                }\n            });\n            $164a8b1918bfc2fb$var$scrollCtaTimeline.to(ctaLine, {\n                scaleY: 1,\n                duration: 1,\n                ease: \"expo.inOut\"\n            }).set(ctaLine, {\n                transformOrigin: 'bottom center',\n                immediateRender: false\n            }).to(ctaLine, {\n                scaleY: 0,\n                duration: 1,\n                ease: \"expo.inOut\"\n            });\n            // Control visibility using enter/back handlers similar to the Home page CTA logic.\n            // Choose a sensible trigger element: prefer projects section, fall back to content shell or body.\n            const triggerEl = document.querySelector('.projects-section-shell') || document.querySelector('.content-shell') || document.body;\n            const ctaTrigger = (0, $hR2D0.ScrollTrigger).create({\n                trigger: triggerEl,\n                start: 'top bottom',\n                // When the trigger enters the viewport (i.e., page scrolled down), hide/pause CTA\n                onEnter: ()=>{\n                    // Avoid pausing on transient refreshes when user is effectively at top\n                    const sc = window.scrollY || window.pageYOffset || 0;\n                    // CTA onEnter - scrolly\n                    if (sc <= 20) // CTA onEnter - near top, skip pause\n                    return;\n                    if ($164a8b1918bfc2fb$var$scrollCtaTimeline) // CTA - pause() called\n                    $164a8b1918bfc2fb$var$scrollCtaTimeline.pause();\n                    const hideTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n                    if (hideTargets.length) (0, $2bvox.gsap).to(hideTargets, {\n                        opacity: 0,\n                        duration: 0.3,\n                        stagger: 0.1\n                    });\n                },\n                // When leaving back to the top (entering back), show/play CTA\n                onLeaveBack: ()=>{\n                    // CTA onLeaveBack - playing CTA\n                    if ($164a8b1918bfc2fb$var$scrollCtaTimeline) // CTA - play() called\n                    $164a8b1918bfc2fb$var$scrollCtaTimeline.play();\n                    const showTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n                    if (showTargets.length) (0, $2bvox.gsap).to(showTargets, {\n                        opacity: 1,\n                        duration: 0.3,\n                        stagger: 0.1\n                    });\n                },\n                // Re-evaluate CTA state on ScrollTrigger refresh (important when ScrollSmoother re-inits)\n                onRefresh: (self)=>{\n                    try {\n                        const rect = triggerEl.getBoundingClientRect();\n                        const entered = rect.top <= window.innerHeight;\n                        // CTA onRefresh rect.top\n                        const refreshTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n                        if (entered) {\n                            if ($164a8b1918bfc2fb$var$scrollCtaTimeline) $164a8b1918bfc2fb$var$scrollCtaTimeline.pause();\n                            if (refreshTargets.length) (0, $2bvox.gsap).set(refreshTargets, {\n                                opacity: 0\n                            });\n                        } else {\n                            if ($164a8b1918bfc2fb$var$scrollCtaTimeline) $164a8b1918bfc2fb$var$scrollCtaTimeline.play();\n                            if (refreshTargets.length) (0, $2bvox.gsap).set(refreshTargets, {\n                                opacity: 1\n                            });\n                        }\n                    } catch (e) {\n                        console.warn('[Project] CTA onRefresh error', e);\n                    }\n                }\n            });\n            $164a8b1918bfc2fb$var$projectScrollTriggers.push(ctaTrigger);\n            // Schedule a delayed refresh so ScrollTrigger recalculates once ScrollSmoother/Barba settle.\n            // This helps the CTA initial visibility on first landing.\n            setTimeout(()=>{\n                try {\n                    (0, $hR2D0.ScrollTrigger).refresh(true);\n                } catch (e) {}\n            }, 120);\n            // Ensure initial CTA state matches current element position AFTER layout settles.\n            // Using getBoundingClientRect gives a reliable viewport-relative position even when\n            // ScrollSmoother applies transforms. Run inside rAF to ensure layout is ready.\n            requestAnimationFrame(()=>{\n                try {\n                    const rect = triggerEl.getBoundingClientRect();\n                    const entered = rect.top <= window.innerHeight; // matches `start: 'top bottom'`\n                    if (entered) {\n                        if ($164a8b1918bfc2fb$var$scrollCtaTimeline) $164a8b1918bfc2fb$var$scrollCtaTimeline.pause();\n                        (0, $2bvox.gsap).set([\n                            '.scroll-cta-line',\n                            '.scroll-cta-txt'\n                        ], {\n                            opacity: 0\n                        });\n                    } else {\n                        if ($164a8b1918bfc2fb$var$scrollCtaTimeline) $164a8b1918bfc2fb$var$scrollCtaTimeline.play();\n                        (0, $2bvox.gsap).set([\n                            '.scroll-cta-line',\n                            '.scroll-cta-txt'\n                        ], {\n                            opacity: 1\n                        });\n                    }\n                } catch (e) {\n                /* ignore */ }\n            });\n        }, 50);\n        // Control visibility based on scroll position (moved inside setTimeout)\n        // Add indicator items animation only if element exists\n        const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n        const projectsSectionShell = document.querySelector('.projects-section-shell');\n        const linksIntroShell = document.querySelector('.links-intro-shell');\n        if (indicatorShells.length && projectsSectionShell) {\n            // Force them hidden with inline style AND GSAP, with transform\n            indicatorShells.forEach((shell)=>{\n                shell.style.visibility = 'hidden';\n                shell.style.opacity = '0';\n                shell.style.transform = 'translate3d(-300px, 0, 0)';\n            });\n            (0, $2bvox.gsap).set(indicatorShells, {\n                x: -300,\n                autoAlpha: 0\n            });\n            let projectsSectionTrigger = null;\n            let linksIntroTrigger = null;\n            let triggersEnabled = false;\n            // Wait for actual user interaction before enabling triggers\n            const enableTriggers = ()=>{\n                if (triggersEnabled) return;\n                triggersEnabled = true;\n                // Remove inline styles so GSAP can control, but keep them hidden\n                indicatorShells.forEach((shell)=>{\n                    shell.style.visibility = '';\n                    shell.style.opacity = '';\n                    shell.style.transform = '';\n                });\n                // Ensure they stay hidden with GSAP until ScrollTrigger shows them\n                (0, $2bvox.gsap).set(indicatorShells, {\n                    x: -300,\n                    autoAlpha: 0\n                });\n                window.removeEventListener('wheel', enableTriggers);\n                window.removeEventListener('touchmove', enableTriggers);\n            };\n            // Listen for wheel/touch - these are actual user scroll interactions\n            window.addEventListener('wheel', enableTriggers, {\n                passive: true,\n                once: true\n            });\n            window.addEventListener('touchmove', enableTriggers, {\n                passive: true,\n                once: true\n            });\n            // Use guarded gsap.to calls and kill overlapping tweens to avoid snapping/popping\n            projectsSectionTrigger = (0, $hR2D0.ScrollTrigger).create({\n                trigger: projectsSectionShell,\n                start: 'top 35%',\n                onEnter: ()=>{\n                    if (!triggersEnabled) return;\n                    // Also check if links intro has been passed\n                    if (linksIntroTrigger && linksIntroTrigger.isActive) return;\n                    (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                    (0, $2bvox.gsap).to(indicatorShells, {\n                        x: 0,\n                        autoAlpha: 1,\n                        duration: 1,\n                        stagger: 0.15,\n                        ease: \"expo.out\",\n                        overwrite: 'auto'\n                    });\n                },\n                onLeaveBack: ()=>{\n                    if (!triggersEnabled) return;\n                    (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                    (0, $2bvox.gsap).to(indicatorShells, {\n                        x: -300,\n                        autoAlpha: 0,\n                        duration: 0.5,\n                        stagger: 0.1,\n                        ease: \"expo.in\",\n                        overwrite: 'auto'\n                    });\n                }\n            });\n            $164a8b1918bfc2fb$var$projectScrollTriggers.push(projectsSectionTrigger);\n            // Add trigger to hide indicators when links-intro-shell enters viewport\n            if (linksIntroShell) {\n                linksIntroTrigger = (0, $hR2D0.ScrollTrigger).create({\n                    trigger: linksIntroShell,\n                    start: 'top bottom+=500',\n                    onEnter: ()=>{\n                        if (!triggersEnabled) return;\n                        (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                        (0, $2bvox.gsap).to(indicatorShells, {\n                            x: -300,\n                            autoAlpha: 0,\n                            duration: 0.5,\n                            stagger: 0.1,\n                            ease: \"expo.in\",\n                            overwrite: 'auto'\n                        });\n                    },\n                    onLeaveBack: ()=>{\n                        if (!triggersEnabled) return;\n                        (0, $2bvox.gsap).killTweensOf(indicatorShells);\n                        (0, $2bvox.gsap).to(indicatorShells, {\n                            x: 0,\n                            autoAlpha: 1,\n                            duration: 1,\n                            stagger: 0.15,\n                            ease: \"expo.out\",\n                            overwrite: 'auto'\n                        });\n                    }\n                });\n                $164a8b1918bfc2fb$var$projectScrollTriggers.push(linksIntroTrigger);\n            }\n        }\n        // Ensure ScrollTrigger recalculates after DOM is ready\n        setTimeout(()=>{\n            (0, $hR2D0.ScrollTrigger).refresh(true);\n        }, 50);\n        // Initialize work-links functionality\n        $164a8b1918bfc2fb$var$workLinksModule = (0, $cu1VQ.createWorkLinksModule)();\n        $164a8b1918bfc2fb$var$workLinksModule.init();\n    };\n    // If DOM is already loaded (Barba transition), run immediately; otherwise, wait for DOMContentLoaded\n    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', run);\n    else run();\n}\n\n});\nparcelRegister(\"cu1VQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"createWorkLinksModule\", () => $9169c90245941c36$export$9d19844c9be06738);\n\nvar $2bvox = parcelRequire(\"2bvox\");\nfunction $9169c90245941c36$export$9d19844c9be06738() {\n    // Module-scoped state\n    const state = {\n        workImgShell: null,\n        workLinksShell: null,\n        workLinks: null,\n        workImgMasks: null,\n        currentIndex: 1000,\n        currentVideo: null,\n        currentMask: null,\n        xTo: null,\n        yTo: null,\n        onMouseMovePos: null,\n        onMouseMoveLastY: null,\n        onWorkShellEnter: null,\n        onWorkShellLeave: null,\n        onInitialMouseMove: null\n    };\n    function init() {\n        // Pause all videos\n        document.querySelectorAll('video').forEach((video)=>{\n            video.pause();\n        });\n        const workImgShell = document.querySelector('.work-img-shell');\n        const workLinksShell = document.querySelector('.work-links-shell');\n        const workLinks = document.querySelectorAll('.work-links-item');\n        const workImgMasks = document.querySelectorAll('.work-img-mask');\n        state.workImgShell = workImgShell;\n        state.workLinksShell = workLinksShell;\n        state.workLinks = workLinks;\n        state.workImgMasks = workImgMasks;\n        // Number work link blocks (format: \"01 /\", \"02 /\")\n        try {\n            const elems = Array.from(document.querySelectorAll('.work-link-num-txt'));\n            if (elems && elems.length) {\n                const total = elems.length;\n                const padLen = Math.max(2, String(total).length);\n                elems.forEach((el, i)=>{\n                    try {\n                        const n = String(i + 1).padStart(padLen, '0');\n                        el.innerHTML = `${n} /`;\n                    } catch (e) {}\n                });\n            }\n        } catch (e) {}\n        if (!workImgShell || !workLinksShell) return;\n        // Set initial state for first mask immediately\n        if (workImgMasks.length > 0) {\n            const firstMask = workImgMasks[0];\n            (0, $2bvox.gsap).set(firstMask, {\n                zIndex: state.currentIndex\n            });\n            const firstAnimeElement = firstMask.querySelector('.work-img-mask-anime');\n            if (firstAnimeElement) {\n                (0, $2bvox.gsap).set(firstAnimeElement, {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    height: '100%',\n                    overflow: 'hidden'\n                });\n                state.currentMask = firstMask;\n                // Play first video if exists\n                const firstVideo = firstMask.querySelector('video');\n                if (firstVideo) {\n                    firstVideo.play();\n                    state.currentVideo = firstVideo;\n                }\n            }\n        }\n        // Reset and set initial state\n        workImgShell.style.cssText = '';\n        (0, $2bvox.gsap).set(workImgShell, {\n            opacity: 0,\n            xPercent: -50,\n            yPercent: -50,\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: 9999,\n            pointerEvents: 'none'\n        });\n        // Create quickTo animations\n        const xTo = (0, $2bvox.gsap).quickTo(workImgShell, \"x\", {\n            duration: 1.2,\n            ease: \"expo.out\"\n        });\n        const yTo = (0, $2bvox.gsap).quickTo(workImgShell, \"y\", {\n            duration: 1.2,\n            ease: \"expo.out\"\n        });\n        state.xTo = xTo;\n        state.yTo = yTo;\n        // Mouse move handler using content-shell position\n        const onMouseMovePos = (e)=>{\n            const shellYoffset = document.querySelector('.content-shell').getBoundingClientRect().top;\n            xTo(e.clientX);\n            yTo(e.clientY - shellYoffset);\n        };\n        state.onMouseMovePos = onMouseMovePos;\n        window.addEventListener(\"mousemove\", onMouseMovePos);\n        // Container hover handling for both shells\n        const handleContainerHover = (enter)=>{\n            (0, $2bvox.gsap).killTweensOf(workImgShell, \"opacity\");\n            (0, $2bvox.gsap).to(workImgShell, {\n                opacity: enter ? 1 : 0,\n                scale: enter ? 1 : 0.8,\n                duration: enter ? 0.6 : 0.3,\n                ease: \"expo.out\"\n            });\n            if (enter && state.currentMask) {\n                const video = state.currentMask.querySelector('video');\n                if (video) {\n                    video.play();\n                    state.currentVideo = video;\n                }\n            } else if (!enter && state.currentVideo) {\n                state.currentVideo.pause();\n                state.currentVideo = null;\n            }\n        };\n        state.onWorkShellEnter = ()=>handleContainerHover(true);\n        state.onWorkShellLeave = ()=>handleContainerHover(false);\n        workLinksShell.addEventListener('mouseenter', state.onWorkShellEnter);\n        workLinksShell.addEventListener('mouseleave', state.onWorkShellLeave);\n        workImgShell.addEventListener('mouseenter', state.onWorkShellEnter);\n        workImgShell.addEventListener('mouseleave', state.onWorkShellLeave);\n        // Add mouse position tracking\n        let lastMouseY = 0;\n        const onMouseMoveLastY = (e)=>{\n            lastMouseY = e.clientY;\n        };\n        state.onMouseMoveLastY = onMouseMoveLastY;\n        window.addEventListener('mousemove', onMouseMoveLastY);\n        // Helper function to normalize text by removing accents and converting to slug format\n        const normalizeToSlug = (text)=>{\n            return text.trim().toLowerCase().normalize('NFD') // Decompose accented characters\n            .replace(/[\\u0300-\\u036f]/g, '') // Remove diacritical marks\n            .replace(/\\s+/g, '-'); // Replace spaces with hyphens\n        };\n        // Check current project URL and disable matching links\n        const currentPath = window.location.pathname;\n        const projectMatch = currentPath.match(/projects\\/([^\\/]+)/);\n        const currentProjectSlug = projectMatch ? normalizeToSlug(projectMatch[1]) : null;\n        // Handle matching z-index updates and video control\n        workLinks.forEach((link, index)=>{\n            // Check if this link matches the current project\n            let isCurrentProject = false;\n            if (currentProjectSlug) {\n                // Check href for match\n                const href = link.getAttribute('href');\n                if (href && href.includes(`projects/`)) {\n                    const linkSlugMatch = href.match(/projects\\/([^\\/]+)/);\n                    if (linkSlugMatch) {\n                        const linkSlug = normalizeToSlug(linkSlugMatch[1]);\n                        if (linkSlug === currentProjectSlug) isCurrentProject = true;\n                    }\n                }\n                // Also check headline text for match (normalize both strings)\n                if (!isCurrentProject) {\n                    const headlineEl = link.querySelector('.work-link-headline-txt');\n                    if (headlineEl) {\n                        const headlineSlug = normalizeToSlug(headlineEl.textContent);\n                        if (headlineSlug === currentProjectSlug) isCurrentProject = true;\n                    }\n                }\n            }\n            // Check if link contains \"Coming Soon\" text\n            let isComingSoon = false;\n            const linkText = link.textContent || link.innerText || '';\n            if (linkText.toLowerCase().includes('coming soon')) isComingSoon = true;\n            // If this is the current project or coming soon, prevent clicks but keep hover\n            if (isCurrentProject || isComingSoon) {\n                link.style.opacity = '0.5';\n                link.setAttribute('data-current-project', 'true');\n                // Prevent click navigation\n                link.addEventListener('click', (e)=>{\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n            }\n            link.addEventListener('mouseenter', (e)=>{\n                state.currentIndex++;\n                // Animate text color to black\n                const textElements = link.querySelectorAll('*');\n                if (textElements.length) (0, $2bvox.gsap).to(textElements, {\n                    color: '#000000',\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                // Animate work-link-num to the right\n                const workLinkNum = link.querySelector('.work-link-num');\n                if (workLinkNum) (0, $2bvox.gsap).to(workLinkNum, {\n                    x: 30,\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                // Animate work-link-client to the left\n                const workLinkClient = link.querySelector('.work-link-client');\n                if (workLinkClient) (0, $2bvox.gsap).to(workLinkClient, {\n                    x: -30,\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                // Animate links-bg with directional scale\n                const linksBg = link.querySelector('.links-bg');\n                if (linksBg) {\n                    const rect = link.getBoundingClientRect();\n                    const elementCenter = rect.top + rect.height / 2;\n                    const fromTop = lastMouseY < elementCenter;\n                    (0, $2bvox.gsap).killTweensOf(linksBg);\n                    (0, $2bvox.gsap).set(linksBg, {\n                        transformOrigin: fromTop ? 'top center' : 'bottom center',\n                        scaleY: 0\n                    });\n                    (0, $2bvox.gsap).to(linksBg, {\n                        scaleY: 1,\n                        duration: 0.6,\n                        ease: \"expo.out\"\n                    });\n                }\n                // Skip animation if it's the first item and we're just starting\n                if (index === 0 && state.currentMask === workImgMasks[0]) return;\n                // Pause current video if exists\n                if (state.currentVideo) state.currentVideo.pause();\n                const correspondingMask = workImgMasks[index];\n                if (correspondingMask && correspondingMask !== state.currentMask) {\n                    state.currentMask = correspondingMask;\n                    (0, $2bvox.gsap).set(correspondingMask, {\n                        zIndex: state.currentIndex\n                    });\n                    const animeElement = correspondingMask.querySelector('.work-img-mask-anime');\n                    if (animeElement) {\n                        const children = animeElement.children;\n                        (0, $2bvox.gsap).killTweensOf([\n                            animeElement,\n                            children\n                        ]);\n                        const rect = correspondingMask.getBoundingClientRect();\n                        const elementCenter = rect.top + rect.height / 2;\n                        const fromTop = lastMouseY < elementCenter;\n                        (0, $2bvox.gsap).set(animeElement, {\n                            position: 'absolute',\n                            top: fromTop ? 'auto' : 0,\n                            bottom: fromTop ? 0 : 'auto',\n                            left: 0,\n                            right: 0,\n                            height: '0%',\n                            overflow: 'hidden'\n                        });\n                        (0, $2bvox.gsap).timeline().to(animeElement, {\n                            height: '100%',\n                            duration: 1.1,\n                            ease: \"expo.out\"\n                        });\n                    }\n                    const video = correspondingMask.querySelector('video');\n                    if (video) {\n                        video.play();\n                        state.currentVideo = video;\n                    }\n                }\n            });\n            link.addEventListener('mouseleave', (e)=>{\n                // Animate text color back to white\n                const textElements = link.querySelectorAll('*');\n                if (textElements.length) (0, $2bvox.gsap).to(textElements, {\n                    color: '#FFFFFF',\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                // Animate work-link-num back to original position\n                const workLinkNum = link.querySelector('.work-link-num');\n                if (workLinkNum) (0, $2bvox.gsap).to(workLinkNum, {\n                    x: 0,\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                // Animate work-link-client back to original position\n                const workLinkClient = link.querySelector('.work-link-client');\n                if (workLinkClient) (0, $2bvox.gsap).to(workLinkClient, {\n                    x: 0,\n                    duration: 0.4,\n                    ease: \"power2.out\"\n                });\n                const linksBg = link.querySelector('.links-bg');\n                if (linksBg) {\n                    const rect = link.getBoundingClientRect();\n                    const elementCenter = rect.top + rect.height / 2;\n                    const fromTop = e.clientY < elementCenter;\n                    (0, $2bvox.gsap).killTweensOf(linksBg);\n                    (0, $2bvox.gsap).set(linksBg, {\n                        transformOrigin: fromTop ? 'top center' : 'bottom center'\n                    });\n                    (0, $2bvox.gsap).to(linksBg, {\n                        scaleY: 0,\n                        duration: 0.6,\n                        ease: \"expo.out\"\n                    });\n                }\n            });\n        });\n        // Check if cursor is over element\n        const isCursorOverElement = (element, x, y)=>{\n            const rect = element.getBoundingClientRect();\n            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n        };\n        // Check initial cursor position\n        const checkInitialCursor = (e)=>{\n            if (isCursorOverElement(workLinksShell, e.clientX, e.clientY)) handleContainerHover(true);\n            document.removeEventListener('mousemove', checkInitialCursor);\n        };\n        const onInitialMouseMove = checkInitialCursor;\n        state.onInitialMouseMove = onInitialMouseMove;\n        document.addEventListener('mousemove', onInitialMouseMove);\n    }\n    function cleanup() {\n        try {\n            // Pause all videos\n            document.querySelectorAll('video').forEach((video)=>{\n                try {\n                    video.pause();\n                } catch (e) {}\n            });\n            // Remove window listeners\n            if (state.onMouseMovePos) window.removeEventListener('mousemove', state.onMouseMovePos);\n            if (state.onMouseMoveLastY) window.removeEventListener('mousemove', state.onMouseMoveLastY);\n            if (state.onInitialMouseMove) document.removeEventListener('mousemove', state.onInitialMouseMove);\n            // Remove shell listeners\n            if (state.workLinksShell) {\n                state.workLinksShell.removeEventListener('mouseenter', state.onWorkShellEnter);\n                state.workLinksShell.removeEventListener('mouseleave', state.onWorkShellLeave);\n            }\n            if (state.workImgShell) {\n                state.workImgShell.removeEventListener('mouseenter', state.onWorkShellEnter);\n                state.workImgShell.removeEventListener('mouseleave', state.onWorkShellLeave);\n            }\n            // Remove per-link listeners\n            if (state.workLinks && state.workLinks.length) state.workLinks.forEach((link)=>{\n                try {\n                    const clone = link.cloneNode(true);\n                    link.parentNode.replaceChild(clone, link);\n                } catch (e) {}\n            });\n            // Kill tweens\n            try {\n                (0, $2bvox.gsap).killTweensOf(state.workImgShell);\n            } catch (e) {}\n            try {\n                (0, $2bvox.gsap).killTweensOf(state.workImgShell && state.workImgShell.children);\n            } catch (e) {}\n            // Clear state\n            Object.keys(state).forEach((key)=>{\n                state[key] = null;\n            });\n            state.currentIndex = 1000;\n        } catch (e) {\n            console.warn('workLinksModule cleanup error', e);\n        }\n    }\n    return {\n        init: init,\n        cleanup: cleanup\n    };\n}\n\n});\n\n\n})();\n//# sourceMappingURL=project.46121a9e.js.map\n","\nimport { gsap } from \"gsap\";\nimport { ScrollTrigger } from \"gsap/ScrollTrigger\";\nimport { SplitText } from \"gsap/SplitText\";\nimport { createWorkLinksModule } from \"./utils/workLinksModule\";\n\nlet projectScrollTriggers = [];\nlet scrollCtaTimeline = null;\nlet workLinksModule = null;\n\nfunction cleanupProjectPage() {\n  // Kill any ScrollTrigger instances for this page\n  projectScrollTriggers.forEach(t => t && t.kill && t.kill());\n  projectScrollTriggers = [];\n\n  // Kill CTA timeline if it exists to avoid duplicate timelines after navigation\n  if (scrollCtaTimeline) {\n    try { scrollCtaTimeline.kill && scrollCtaTimeline.kill(); } catch (e) {}\n    try { scrollCtaTimeline.pause && scrollCtaTimeline.pause(); } catch (e) {}\n    scrollCtaTimeline = null;\n  }\n\n  // Cleanup work-links module\n  if (workLinksModule) {\n    workLinksModule.cleanup();\n    workLinksModule = null;\n  }\n}\n\ngsap.registerPlugin(ScrollTrigger, SplitText);\n\n\nfunction initProjectPage() {\n  // initProjectPage called\n  const run = () => {\n    cleanupProjectPage();\n    // Ensure page is at top on initial run (fix preserved scroll on refresh)\n    try {\n      console.log('[project] initProjectPage: attempting robust scroll reset');\n      const tryReset = () => {\n        try {\n          if (typeof window !== 'undefined' && window._smootherInstance && typeof window._smootherInstance.scrollTo === 'function') {\n            window._smootherInstance.scrollTo(0, false);\n            return true;\n          }\n        } catch (e) {}\n        try {\n          window.scrollTo(0, 0);\n          return true;\n        } catch (e) { return false; }\n      };\n\n      // immediate attempt\n      tryReset();\n      // after paint (double rAF)\n      requestAnimationFrame(() => requestAnimationFrame(() => tryReset()));\n      // short timeout in case smoother initializes slightly later\n      setTimeout(() => {\n        tryReset();\n        // After scroll reset, aggressively hide indicators\n        const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n        if (indicatorShells.length) {\n          try {\n            gsap.killTweensOf(indicatorShells);\n            gsap.set(indicatorShells, { x: -150, autoAlpha: 0 });\n          } catch (e) {}\n        }\n      }, 120);\n      // final attempt on full load (once)\n      const onLoad = () => { \n        tryReset();\n        // After scroll reset on load, aggressively hide indicators\n        const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n        if (indicatorShells.length) {\n          try {\n            gsap.killTweensOf(indicatorShells);\n            gsap.set(indicatorShells, { x: -150, autoAlpha: 0 });\n          } catch (e) {}\n        }\n        window.removeEventListener('load', onLoad); \n      };\n      try { window.addEventListener('load', onLoad); } catch (e) {}\n    } catch (e) {}\n    const isProjectPage = window.location.pathname.includes('/projects');\n    if (!isProjectPage) return;\n\n    // Set initial states separately (only if elements exist to avoid GSAP warnings)\n    const preCtaLine = document.querySelector('.scroll-cta-line');\n    const preCtaTxt = document.querySelector('.scroll-cta-txt');\n    if (preCtaTxt) {\n      gsap.set(preCtaTxt, { opacity: 1 });\n    }\n    if (preCtaLine) {\n      gsap.set(preCtaLine, {\n        opacity: 1,\n        scaleY: 0,\n        transformOrigin: 'top center'\n      });\n    }\n\n    // Delay creation to ensure DOM is ready and element exists\n    setTimeout(() => {\n      const ctaLine = document.querySelector('.scroll-cta-line');\n      const ctaTxt = document.querySelector('.scroll-cta-txt');\n      if (!ctaLine || !ctaTxt) {\n  // CTA elements not found; skipping CTA timeline\n        return;\n      }\n      // create/replace module-scoped CTA timeline\n      scrollCtaTimeline = gsap.timeline({\n        repeat: -1,\n        defaults: { duration: 1, ease: \"expo.inOut\" }\n      });\n      \n      scrollCtaTimeline\n        .to(ctaLine, {\n          scaleY: 1,\n          duration: 1,\n          ease: \"expo.inOut\"\n        })\n        .set(ctaLine, {\n          transformOrigin: 'bottom center',\n          immediateRender: false\n        })\n        .to(ctaLine, {\n          scaleY: 0,\n          duration: 1,\n          ease: \"expo.inOut\"\n        });\n\n      // Control visibility using enter/back handlers similar to the Home page CTA logic.\n      // Choose a sensible trigger element: prefer projects section, fall back to content shell or body.\n      const triggerEl = document.querySelector('.projects-section-shell') || document.querySelector('.content-shell') || document.body;\n      const ctaTrigger = ScrollTrigger.create({\n        trigger: triggerEl,\n        start: 'top bottom',\n        // When the trigger enters the viewport (i.e., page scrolled down), hide/pause CTA\n        onEnter: () => {\n          // Avoid pausing on transient refreshes when user is effectively at top\n          const sc = (window.scrollY || window.pageYOffset || 0);\n          // CTA onEnter - scrolly\n          if (sc <= 20) {\n            // CTA onEnter - near top, skip pause\n            return;\n          }\n          if (scrollCtaTimeline) {\n            // CTA - pause() called\n            scrollCtaTimeline.pause();\n          }\n          const hideTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n          if (hideTargets.length) {\n            gsap.to(hideTargets, { opacity: 0, duration: 0.3, stagger: 0.1 });\n          }\n        },\n        // When leaving back to the top (entering back), show/play CTA\n        onLeaveBack: () => {\n          // CTA onLeaveBack - playing CTA\n          if (scrollCtaTimeline) {\n            // CTA - play() called\n            scrollCtaTimeline.play();\n          }\n          const showTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n          if (showTargets.length) {\n            gsap.to(showTargets, { opacity: 1, duration: 0.3, stagger: 0.1 });\n          }\n        },\n        // Re-evaluate CTA state on ScrollTrigger refresh (important when ScrollSmoother re-inits)\n        onRefresh: (self) => {\n          try {\n            const rect = triggerEl.getBoundingClientRect();\n            const entered = rect.top <= window.innerHeight;\n            // CTA onRefresh rect.top\n            const refreshTargets = Array.from(document.querySelectorAll('.scroll-cta-line, .scroll-cta-txt'));\n            if (entered) {\n              if (scrollCtaTimeline) scrollCtaTimeline.pause();\n              if (refreshTargets.length) gsap.set(refreshTargets, { opacity: 0 });\n            } else {\n              if (scrollCtaTimeline) scrollCtaTimeline.play();\n              if (refreshTargets.length) gsap.set(refreshTargets, { opacity: 1 });\n            }\n          } catch (e) { console.warn('[Project] CTA onRefresh error', e); }\n        }\n      });\n  projectScrollTriggers.push(ctaTrigger);\n\n  // Schedule a delayed refresh so ScrollTrigger recalculates once ScrollSmoother/Barba settle.\n  // This helps the CTA initial visibility on first landing.\n  setTimeout(() => { try { ScrollTrigger.refresh(true); } catch (e) { /* ignore */ } }, 120);\n\n  // Ensure initial CTA state matches current element position AFTER layout settles.\n  // Using getBoundingClientRect gives a reliable viewport-relative position even when\n  // ScrollSmoother applies transforms. Run inside rAF to ensure layout is ready.\n  requestAnimationFrame(() => {\n        try {\n          const rect = triggerEl.getBoundingClientRect();\n          const entered = rect.top <= window.innerHeight; // matches `start: 'top bottom'`\n          if (entered) {\n            if (scrollCtaTimeline) { scrollCtaTimeline.pause(); }\n            gsap.set(['.scroll-cta-line', '.scroll-cta-txt'], { opacity: 0 });\n          } else {\n            if (scrollCtaTimeline) { scrollCtaTimeline.play(); }\n            gsap.set(['.scroll-cta-line', '.scroll-cta-txt'], { opacity: 1 });\n          }\n        } catch (e) {\n          /* ignore */\n        }\n      });\n    }, 50);\n\n    // Control visibility based on scroll position (moved inside setTimeout)\n\n    // Add indicator items animation only if element exists\n    const indicatorShells = document.querySelectorAll('.indicator-item-shell');\n    const projectsSectionShell = document.querySelector('.projects-section-shell');\n    const linksIntroShell = document.querySelector('.links-intro-shell');\n    \n    if (indicatorShells.length && projectsSectionShell) {\n      // Force them hidden with inline style AND GSAP, with transform\n      indicatorShells.forEach(shell => {\n        shell.style.visibility = 'hidden';\n        shell.style.opacity = '0';\n        shell.style.transform = 'translate3d(-300px, 0, 0)';\n      });\n      gsap.set(indicatorShells, { x: -300, autoAlpha: 0 });\n\n      let projectsSectionTrigger = null;\n      let linksIntroTrigger = null;\n      let triggersEnabled = false;\n\n      // Wait for actual user interaction before enabling triggers\n      const enableTriggers = () => {\n        if (triggersEnabled) return;\n        triggersEnabled = true;\n        \n        // Remove inline styles so GSAP can control, but keep them hidden\n        indicatorShells.forEach(shell => {\n          shell.style.visibility = '';\n          shell.style.opacity = '';\n          shell.style.transform = '';\n        });\n        \n        // Ensure they stay hidden with GSAP until ScrollTrigger shows them\n        gsap.set(indicatorShells, { x: -300, autoAlpha: 0 });\n        \n        window.removeEventListener('wheel', enableTriggers);\n        window.removeEventListener('touchmove', enableTriggers);\n      };\n      \n      // Listen for wheel/touch - these are actual user scroll interactions\n      window.addEventListener('wheel', enableTriggers, { passive: true, once: true });\n      window.addEventListener('touchmove', enableTriggers, { passive: true, once: true });\n\n      // Use guarded gsap.to calls and kill overlapping tweens to avoid snapping/popping\n      projectsSectionTrigger = ScrollTrigger.create({\n        trigger: projectsSectionShell,\n        start: 'top 35%',\n        onEnter: () => {\n          if (!triggersEnabled) return;\n          // Also check if links intro has been passed\n          if (linksIntroTrigger && linksIntroTrigger.isActive) return;\n          \n          gsap.killTweensOf(indicatorShells);\n          gsap.to(indicatorShells, {\n            x: 0,\n            autoAlpha: 1,\n            duration: 1,\n            stagger: 0.15,\n            ease: \"expo.out\",\n            overwrite: 'auto'\n          });\n        },\n        onLeaveBack: () => {\n          if (!triggersEnabled) return;\n          gsap.killTweensOf(indicatorShells);\n          gsap.to(indicatorShells, {\n            x: -300,\n            autoAlpha: 0,\n            duration: 0.5,\n            stagger: 0.1,\n            ease: \"expo.in\",\n            overwrite: 'auto'\n          });\n        }\n      });\n      projectScrollTriggers.push(projectsSectionTrigger);\n\n      // Add trigger to hide indicators when links-intro-shell enters viewport\n      if (linksIntroShell) {\n        linksIntroTrigger = ScrollTrigger.create({\n          trigger: linksIntroShell,\n          start: 'top bottom+=500',\n          onEnter: () => {\n            if (!triggersEnabled) return;\n            gsap.killTweensOf(indicatorShells);\n            gsap.to(indicatorShells, {\n              x: -300,\n              autoAlpha: 0,\n              duration: 0.5,\n              stagger: 0.1,\n              ease: \"expo.in\",\n              overwrite: 'auto'\n            });\n          },\n          onLeaveBack: () => {\n            if (!triggersEnabled) return;\n            gsap.killTweensOf(indicatorShells);\n            gsap.to(indicatorShells, {\n              x: 0,\n              autoAlpha: 1,\n              duration: 1,\n              stagger: 0.15,\n              ease: \"expo.out\",\n              overwrite: 'auto'\n            });\n          }\n        });\n        projectScrollTriggers.push(linksIntroTrigger);\n      }\n    }\n\n    // Ensure ScrollTrigger recalculates after DOM is ready\n    setTimeout(() => {\n      ScrollTrigger.refresh(true);\n    }, 50);\n\n    // Initialize work-links functionality\n    workLinksModule = createWorkLinksModule();\n    workLinksModule.init();\n  }\n\n\n\n\n  // If DOM is already loaded (Barba transition), run immediately; otherwise, wait for DOMContentLoaded\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', run);\n  } else {\n    run();\n  }\n}\n\nexport { initProjectPage, cleanupProjectPage };\n\n","import { gsap } from \"gsap\";\n\n// Shared work-links functionality that can be used by multiple pages\nexport function createWorkLinksModule() {\n  // Module-scoped state\n  const state = {\n    workImgShell: null,\n    workLinksShell: null,\n    workLinks: null,\n    workImgMasks: null,\n    currentIndex: 1000,\n    currentVideo: null,\n    currentMask: null,\n    xTo: null,\n    yTo: null,\n    onMouseMovePos: null,\n    onMouseMoveLastY: null,\n    onWorkShellEnter: null,\n    onWorkShellLeave: null,\n    onInitialMouseMove: null\n  };\n\n  function init() {\n    // Pause all videos\n    document.querySelectorAll('video').forEach(video => {\n      video.pause();\n    });\n\n    const workImgShell = document.querySelector('.work-img-shell');\n    const workLinksShell = document.querySelector('.work-links-shell');\n    const workLinks = document.querySelectorAll('.work-links-item');\n    const workImgMasks = document.querySelectorAll('.work-img-mask');\n    \n    state.workImgShell = workImgShell;\n    state.workLinksShell = workLinksShell;\n    state.workLinks = workLinks;\n    state.workImgMasks = workImgMasks;\n\n    // Number work link blocks (format: \"01 /\", \"02 /\")\n    try {\n      const elems = Array.from(document.querySelectorAll('.work-link-num-txt'));\n      if (elems && elems.length) {\n        const total = elems.length;\n        const padLen = Math.max(2, String(total).length);\n        elems.forEach((el, i) => {\n          try {\n            const n = String(i + 1).padStart(padLen, '0');\n            el.innerHTML = `${n} /`;\n          } catch (e) {}\n        });\n      }\n    } catch (e) {}\n\n    if (!workImgShell || !workLinksShell) return;\n\n    // Set initial state for first mask immediately\n    if (workImgMasks.length > 0) {\n      const firstMask = workImgMasks[0];\n      gsap.set(firstMask, { zIndex: state.currentIndex });\n      \n      const firstAnimeElement = firstMask.querySelector('.work-img-mask-anime');\n      if (firstAnimeElement) {\n        gsap.set(firstAnimeElement, { \n          position: 'absolute',\n          top: 0,\n          left: 0,\n          right: 0,\n          height: '100%',\n          overflow: 'hidden'\n        });\n        state.currentMask = firstMask;\n\n        // Play first video if exists\n        const firstVideo = firstMask.querySelector('video');\n        if (firstVideo) {\n          firstVideo.play();\n          state.currentVideo = firstVideo;\n        }\n      }\n    }\n\n    // Reset and set initial state\n    workImgShell.style.cssText = '';\n    gsap.set(workImgShell, {\n      opacity: 0,\n      xPercent: -50,\n      yPercent: -50,\n      position: 'fixed',\n      top: '0',\n      left: '0',\n      zIndex: 9999,\n      pointerEvents: 'none'\n    });\n\n    // Create quickTo animations\n    const xTo = gsap.quickTo(workImgShell, \"x\", {duration: 1.2, ease: \"expo.out\"});\n    const yTo = gsap.quickTo(workImgShell, \"y\", {duration: 1.2, ease: \"expo.out\"});\n    state.xTo = xTo;\n    state.yTo = yTo;\n\n    // Mouse move handler using content-shell position\n    const onMouseMovePos = (e) => {\n      const shellYoffset = document.querySelector('.content-shell').getBoundingClientRect().top;\n      xTo(e.clientX);\n      yTo(e.clientY - shellYoffset);\n    };\n    state.onMouseMovePos = onMouseMovePos;\n    window.addEventListener(\"mousemove\", onMouseMovePos);\n\n    // Container hover handling for both shells\n    const handleContainerHover = (enter) => {\n      gsap.killTweensOf(workImgShell, \"opacity\");\n      gsap.to(workImgShell, {\n        opacity: enter ? 1 : 0,\n        scale: enter ? 1 : 0.8,\n        duration: enter ? 0.6 : 0.3,\n        ease: \"expo.out\"\n      });\n\n      if (enter && state.currentMask) {\n        const video = state.currentMask.querySelector('video');\n        if (video) {\n          video.play();\n          state.currentVideo = video;\n        }\n      } else if (!enter && state.currentVideo) {\n        state.currentVideo.pause();\n        state.currentVideo = null;\n      }\n    };\n\n    state.onWorkShellEnter = () => handleContainerHover(true);\n    state.onWorkShellLeave = () => handleContainerHover(false);\n    workLinksShell.addEventListener('mouseenter', state.onWorkShellEnter);\n    workLinksShell.addEventListener('mouseleave', state.onWorkShellLeave);\n    workImgShell.addEventListener('mouseenter', state.onWorkShellEnter);\n    workImgShell.addEventListener('mouseleave', state.onWorkShellLeave);\n\n    // Add mouse position tracking\n    let lastMouseY = 0;\n    const onMouseMoveLastY = (e) => { lastMouseY = e.clientY; };\n    state.onMouseMoveLastY = onMouseMoveLastY;\n    window.addEventListener('mousemove', onMouseMoveLastY);\n\n    // Helper function to normalize text by removing accents and converting to slug format\n    const normalizeToSlug = (text) => {\n      return text\n        .trim()\n        .toLowerCase()\n        .normalize('NFD') // Decompose accented characters\n        .replace(/[\\u0300-\\u036f]/g, '') // Remove diacritical marks\n        .replace(/\\s+/g, '-'); // Replace spaces with hyphens\n    };\n\n    // Check current project URL and disable matching links\n    const currentPath = window.location.pathname;\n    const projectMatch = currentPath.match(/projects\\/([^\\/]+)/);\n    const currentProjectSlug = projectMatch ? normalizeToSlug(projectMatch[1]) : null;\n\n    // Handle matching z-index updates and video control\n    workLinks.forEach((link, index) => {\n      // Check if this link matches the current project\n      let isCurrentProject = false;\n      \n      if (currentProjectSlug) {\n        // Check href for match\n        const href = link.getAttribute('href');\n        if (href && href.includes(`projects/`)) {\n          const linkSlugMatch = href.match(/projects\\/([^\\/]+)/);\n          if (linkSlugMatch) {\n            const linkSlug = normalizeToSlug(linkSlugMatch[1]);\n            if (linkSlug === currentProjectSlug) {\n              isCurrentProject = true;\n            }\n          }\n        }\n        \n        // Also check headline text for match (normalize both strings)\n        if (!isCurrentProject) {\n          const headlineEl = link.querySelector('.work-link-headline-txt');\n          if (headlineEl) {\n            const headlineSlug = normalizeToSlug(headlineEl.textContent);\n            if (headlineSlug === currentProjectSlug) {\n              isCurrentProject = true;\n            }\n          }\n        }\n      }\n      \n      // Check if link contains \"Coming Soon\" text\n      let isComingSoon = false;\n      const linkText = link.textContent || link.innerText || '';\n      if (linkText.toLowerCase().includes('coming soon')) {\n        isComingSoon = true;\n      }\n      \n      // If this is the current project or coming soon, prevent clicks but keep hover\n      if (isCurrentProject || isComingSoon) {\n        link.style.opacity = '0.5';\n        link.setAttribute('data-current-project', 'true');\n        // Prevent click navigation\n        link.addEventListener('click', (e) => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      \n      link.addEventListener('mouseenter', (e) => {\n        state.currentIndex++;\n        \n        // Animate text color to black\n        const textElements = link.querySelectorAll('*');\n        if (textElements.length) {\n          gsap.to(textElements, {\n            color: '#000000',\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        // Animate work-link-num to the right\n        const workLinkNum = link.querySelector('.work-link-num');\n        if (workLinkNum) {\n          gsap.to(workLinkNum, {\n            x: 30,\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        // Animate work-link-client to the left\n        const workLinkClient = link.querySelector('.work-link-client');\n        if (workLinkClient) {\n          gsap.to(workLinkClient, {\n            x: -30,\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        // Animate links-bg with directional scale\n        const linksBg = link.querySelector('.links-bg');\n        if (linksBg) {\n          const rect = link.getBoundingClientRect();\n          const elementCenter = rect.top + (rect.height / 2);\n          const fromTop = lastMouseY < elementCenter;\n          \n          gsap.killTweensOf(linksBg);\n          gsap.set(linksBg, {\n            transformOrigin: fromTop ? 'top center' : 'bottom center',\n            scaleY: 0\n          });\n          gsap.to(linksBg, {\n            scaleY: 1,\n            duration: 0.6,\n            ease: \"expo.out\"\n          });\n        }\n\n        // Skip animation if it's the first item and we're just starting\n        if (index === 0 && state.currentMask === workImgMasks[0]) {\n          return;\n        }\n        \n        // Pause current video if exists\n        if (state.currentVideo) {\n          state.currentVideo.pause();\n        }\n        \n        const correspondingMask = workImgMasks[index];\n        if (correspondingMask && correspondingMask !== state.currentMask) {\n          state.currentMask = correspondingMask;\n          gsap.set(correspondingMask, { zIndex: state.currentIndex });\n          \n          const animeElement = correspondingMask.querySelector('.work-img-mask-anime');\n          if (animeElement) {\n            const children = animeElement.children;\n            gsap.killTweensOf([animeElement, children]);\n            \n            const rect = correspondingMask.getBoundingClientRect();\n            const elementCenter = rect.top + (rect.height / 2);\n            const fromTop = lastMouseY < elementCenter;\n            \n            gsap.set(animeElement, { \n              position: 'absolute',\n              top: fromTop ? 'auto' : 0,\n              bottom: fromTop ? 0 : 'auto',\n              left: 0,\n              right: 0,\n              height: '0%',\n              overflow: 'hidden'\n            });\n\n            gsap.timeline()\n              .to(animeElement, {\n                height: '100%',\n                duration: 1.1,\n                ease: \"expo.out\"\n              });\n          }\n          \n          const video = correspondingMask.querySelector('video');\n          if (video) {\n            video.play();\n            state.currentVideo = video;\n          }\n        }\n      });\n\n      link.addEventListener('mouseleave', (e) => {\n        // Animate text color back to white\n        const textElements = link.querySelectorAll('*');\n        if (textElements.length) {\n          gsap.to(textElements, {\n            color: '#FFFFFF',\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        // Animate work-link-num back to original position\n        const workLinkNum = link.querySelector('.work-link-num');\n        if (workLinkNum) {\n          gsap.to(workLinkNum, {\n            x: 0,\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        // Animate work-link-client back to original position\n        const workLinkClient = link.querySelector('.work-link-client');\n        if (workLinkClient) {\n          gsap.to(workLinkClient, {\n            x: 0,\n            duration: 0.4,\n            ease: \"power2.out\"\n          });\n        }\n        \n        const linksBg = link.querySelector('.links-bg');\n        if (linksBg) {\n          const rect = link.getBoundingClientRect();\n          const elementCenter = rect.top + (rect.height / 2);\n          const fromTop = e.clientY < elementCenter;\n          \n          gsap.killTweensOf(linksBg);\n          gsap.set(linksBg, {\n            transformOrigin: fromTop ? 'top center' : 'bottom center'\n          });\n          gsap.to(linksBg, {\n            scaleY: 0,\n            duration: 0.6,\n            ease: \"expo.out\"\n          });\n        }\n      });\n    });\n\n    // Check if cursor is over element\n    const isCursorOverElement = (element, x, y) => {\n      const rect = element.getBoundingClientRect();\n      return (\n        x >= rect.left &&\n        x <= rect.right &&\n        y >= rect.top &&\n        y <= rect.bottom\n      );\n    };\n\n    // Check initial cursor position\n    const checkInitialCursor = (e) => {\n      if (isCursorOverElement(workLinksShell, e.clientX, e.clientY)) {\n        handleContainerHover(true);\n      }\n      document.removeEventListener('mousemove', checkInitialCursor);\n    };\n\n    const onInitialMouseMove = checkInitialCursor;\n    state.onInitialMouseMove = onInitialMouseMove;\n    document.addEventListener('mousemove', onInitialMouseMove);\n  }\n\n  function cleanup() {\n    try {\n      // Pause all videos\n      document.querySelectorAll('video').forEach(video => { try { video.pause(); } catch (e) {} });\n\n      // Remove window listeners\n      if (state.onMouseMovePos) window.removeEventListener('mousemove', state.onMouseMovePos);\n      if (state.onMouseMoveLastY) window.removeEventListener('mousemove', state.onMouseMoveLastY);\n      if (state.onInitialMouseMove) document.removeEventListener('mousemove', state.onInitialMouseMove);\n\n      // Remove shell listeners\n      if (state.workLinksShell) {\n        state.workLinksShell.removeEventListener('mouseenter', state.onWorkShellEnter);\n        state.workLinksShell.removeEventListener('mouseleave', state.onWorkShellLeave);\n      }\n      if (state.workImgShell) {\n        state.workImgShell.removeEventListener('mouseenter', state.onWorkShellEnter);\n        state.workImgShell.removeEventListener('mouseleave', state.onWorkShellLeave);\n      }\n\n      // Remove per-link listeners\n      if (state.workLinks && state.workLinks.length) {\n        state.workLinks.forEach(link => {\n          try {\n            const clone = link.cloneNode(true);\n            link.parentNode.replaceChild(clone, link);\n          } catch (e) {}\n        });\n      }\n\n      // Kill tweens\n      try { gsap.killTweensOf(state.workImgShell); } catch (e) {}\n      try { gsap.killTweensOf(state.workImgShell && state.workImgShell.children); } catch (e) {}\n\n      // Clear state\n      Object.keys(state).forEach(key => {\n        state[key] = null;\n      });\n      state.currentIndex = 1000;\n    } catch (e) {\n      console.warn('workLinksModule cleanup error', e);\n    }\n  }\n\n  return {\n    init,\n    cleanup\n  };\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$164a8b1918bfc2fb$export$1beac54aeac6904a","$164a8b1918bfc2fb$export$95e8c3fdd1a52149","$2bvox","$hR2D0","$gkx87","$cu1VQ","$164a8b1918bfc2fb$var$projectScrollTriggers","$164a8b1918bfc2fb$var$scrollCtaTimeline","$164a8b1918bfc2fb$var$workLinksModule","forEach","t","kill","pause","cleanup","run","console","log","tryReset","window","_smootherInstance","scrollTo","requestAnimationFrame","setTimeout","indicatorShells","document","querySelectorAll","length","gsap","killTweensOf","x","autoAlpha","onLoad","removeEventListener","addEventListener","location","pathname","includes","preCtaLine","querySelector","preCtaTxt","opacity","scaleY","transformOrigin","ctaLine","ctaTxt","timeline","repeat","defaults","duration","ease","to","immediateRender","triggerEl","body","ctaTrigger","ScrollTrigger","create","trigger","start","onEnter","sc","scrollY","pageYOffset","hideTargets","Array","from","stagger","onLeaveBack","play","showTargets","onRefresh","self","entered","rect","getBoundingClientRect","top","innerHeight","refreshTargets","warn","push","refresh","projectsSectionShell","linksIntroShell","shell","style","visibility","transform","projectsSectionTrigger","linksIntroTrigger","triggersEnabled","enableTriggers","passive","once","isActive","overwrite","createWorkLinksModule","init","readyState","registerPlugin","SplitText","$9169c90245941c36$export$9d19844c9be06738","state","workImgShell","workLinksShell","workLinks","workImgMasks","currentIndex","currentVideo","currentMask","xTo","yTo","onMouseMovePos","onMouseMoveLastY","onWorkShellEnter","onWorkShellLeave","onInitialMouseMove","video","elems","total","padLen","Math","max","String","el","i","padStart","innerHTML","firstMask","zIndex","firstAnimeElement","position","left","right","height","overflow","firstVideo","cssText","xPercent","yPercent","pointerEvents","quickTo","shellYoffset","clientX","clientY","handleContainerHover","enter","scale","lastMouseY","normalizeToSlug","text","trim","toLowerCase","normalize","replace","projectMatch","currentPath","match","currentProjectSlug","link","index","isCurrentProject","href","getAttribute","linkSlugMatch","linkSlug","headlineEl","headlineSlug","textContent","isComingSoon","linkText","innerText","setAttribute","preventDefault","stopPropagation","textElements","color","workLinkNum","workLinkClient","linksBg","elementCenter","fromTop","correspondingMask","animeElement","children","bottom","checkInitialCursor","y","element","clone","cloneNode","parentNode","replaceChild","keys","key"],"version":3,"file":"project.46121a9e.js.map"}